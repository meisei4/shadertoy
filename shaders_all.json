{
 "userName": "meisei4",
 "date": "2025-05-19T23:58:39.925Z",
 "numShaders": 32,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "XXyfzc",
    "date": "1738394976",
    "viewed": 54,
    "name": "DS_water_tests",
    "description": "testing DS resolution water stuff",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "water"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifdef __VSCODE__  // Only declare for VS Code linter\nlayout(location = 0) uniform vec3 iResolution;\nlayout(location = 1) uniform float iTime;\nlayout(location = 2) uniform float iTimeDelta;\nlayout(location = 3) uniform int iFrame;\nlayout(location = 4) uniform vec4 iMouse;\n#endif  \n\n#define VIRTUAL_RES_X       256.0   // virtual width in pixels\n#define VIRTUAL_RES_Y       192.0   // virtual height in pixels\n\n#define ZOOM_FACTOR         1.2     // image is magnification value, 1.0 being base 256x192\n\n#define WAVE_FREQUENCY      8.0     //The wave's spatial frequency radians per UV unit \n#define RETRO_LEVELS        4.0     // The number of discrete levels for retro quantization (dimensionless).\n\n#define ANGLE_SPEED_1       0.1     // radians per second\n#define ANGLE_SPEED_2       0.15    // radians per second\n\n#define ANGLE_OFFSET_2      1.0     // radians \n\n// Time multipliers applied before being adding to the UV\n// used to shift the wave computations in the x or y direction (i.e. pixel shift per second)\n#define TIME_OFFSET_X_1     0.3    \n#define TIME_OFFSET_Y_1    -0.3\n#define TIME_OFFSET_X_2    -0.2\n#define TIME_OFFSET_Y_2     0.2\n\n#define BASE_COLOR          vec3(0.0, 0.2, 0.4) \n#define HIGHLIGHT_COLOR     vec3(0.7, 0.9, 1.0)\n\n//pixelates fragments based on provided virtual_res and then zooms with a factor of the virtual_res\nvec2 pixelate_and_zoom_uv(vec2 frag_coord, vec2 resolution, vec2 virtual_resolution, float zoom_factor);\nvec2 pixelate_uv(vec2 uv, vec2 resolution, vec2 virtual_resolution);\nvec2 zoom_uv(vec2 uv, float zoom_factor);\n\n// Computes a combined wave interference pattern using rotations, sine/cosine and iTime offsets\nfloat compute_wave_pattern(vec2 uv, float time, float frequency);\nfloat compute_wave_interference(vec2 uv, float time, float frequency, float time_offset_x, float time_offset_y);\nvec2 rotate_uv(vec2 uv, float angle);\nfloat mix_waves(float wave1, float wave2, float mix_factor);\n\n// Floors a value to a discrete number of levels, then applies a power function: 'levels' is a count of steps\nvec3 compute_color_operations(float wave_value);\nfloat retro_quantize(float value, float levels);\nvec3 mix_colors(vec3 color_a, vec3 color_b, float factor);\n\nfloat compute_wave_pattern_1(vec2 uv, float time, float frequency);\nvec2 distortUV(vec2 uv, float time);\nfloat causticSpot(vec2 uv, vec2 center, float radius);\nfloat fbm(vec2 p);\nfloat noise(vec2 p);\n\n// MAIN SHADERTOY ENTRY FUNCTION\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 final_uv = pixelate_and_zoom_uv(frag_coord, iResolution.xy, vec2(VIRTUAL_RES_X, VIRTUAL_RES_Y), ZOOM_FACTOR);\n    \n    float combined_wave = compute_wave_pattern(final_uv, iTime, WAVE_FREQUENCY);\n    \n    vec3 final_color = compute_color_operations(combined_wave);\n    \n    frag_color = vec4(final_color, 1.0);\n}\n\n\nvec2 pixelate_and_zoom_uv(vec2 frag_coord, vec2 resolution, vec2 virtual_resolution, float zoom_factor) {\n    vec2 uv = frag_coord / resolution;\n    vec2 pixelated_uv = pixelate_uv(uv, resolution, virtual_resolution);\n    return zoom_uv(pixelated_uv, zoom_factor);\n}\n\nvec2 pixelate_uv(vec2 uv, vec2 resolution, vec2 virtual_resolution) {\n    vec2 scaled = uv * resolution;\n    vec2 pixelated = floor(scaled * (virtual_resolution / resolution)) / (virtual_resolution / resolution);\n    return pixelated / resolution;\n}\n\nvec2 zoom_uv(vec2 uv, float zoom_factor) {\n    return uv * zoom_factor;\n}\n\nfloat compute_wave_pattern(vec2 uv, float time, float frequency) {\n    float angle1 = time * ANGLE_SPEED_1;\n    vec2 rotated_uv1 = rotate_uv(uv, angle1);\n    float wave_pattern_1 = compute_wave_interference(rotated_uv1, time, frequency, TIME_OFFSET_X_1, TIME_OFFSET_Y_1);\n\n    float angle2 = time * ANGLE_SPEED_2 + ANGLE_OFFSET_2;\n    vec2 rotated_uv2 = rotate_uv(uv, angle2);\n    float wave_pattern_2 = compute_wave_interference(rotated_uv2, time, frequency, TIME_OFFSET_X_2, TIME_OFFSET_Y_2);\n\n    float base_wave = mix_waves(wave_pattern_1, wave_pattern_2, 0.5);\n    //return base_wave;\n\n    //TODO: NOISE STUFF IS NOT THAT GOOD, IT DOESNT CONTROL PATTERN, ONLY SHAPE OUTLINES\n    float noiseScale = 0.01;\n    float noiseBlend  = 0.001; \n    float noiseValue = fbm(uv * noiseScale + time * 0.01);\n    return mix(base_wave, noiseValue, noiseBlend);\n}\n\n//TODO: This is where to start next time, focus on the blobs/caustic spots, these look promising\nfloat compute_wave_pattern_1(vec2 uv, float time, float frequency) {\n    vec2 distortedUV = distortUV(uv, time);\n    \n    float angle1 = time * ANGLE_SPEED_1;\n    vec2 rotated_uv1 = rotate_uv(distortedUV, angle1);\n    float wave_pattern_1 = compute_wave_interference(rotated_uv1, time, frequency, TIME_OFFSET_X_1, TIME_OFFSET_Y_1);\n\n    float angle2 = time * ANGLE_SPEED_2 + ANGLE_OFFSET_2;\n    vec2 rotated_uv2 = rotate_uv(distortedUV, angle2);\n    float wave_pattern_2 = compute_wave_interference(rotated_uv2, time, frequency, TIME_OFFSET_X_2, TIME_OFFSET_Y_2);\n\n    float base_wave = mix_waves(wave_pattern_1, wave_pattern_2, 0.5);\n    \n    float blobEffect = 0.0;\n    vec2 center1 = vec2(fract(sin(time + 1.0)*43758.5453), fract(cos(time + 1.0)*12345.6789));\n    vec2 center2 = vec2(fract(sin(time + 2.0)*43758.5453), fract(cos(time + 2.0)*12345.6789));\n    blobEffect += causticSpot(distortedUV, center1, 0.1);\n    blobEffect += causticSpot(distortedUV, center2, 0.12);\n    blobEffect = clamp(blobEffect, 0.0, 1.0);\n    \n    float finalPattern = mix(base_wave, blobEffect, 0.3);\n    \n    finalPattern = step(0.5, finalPattern);\n    \n    return finalPattern;\n}\n\nvec2 distortUV(vec2 uv, float time) {\n    float offsetX = fbm(uv * 2.0 + time * 0.1) * 0.05;\n    float offsetY = fbm(uv * 2.0 - time * 0.1) * 0.05;\n    return uv + vec2(offsetX, offsetY);\n}\n\nfloat causticSpot(vec2 uv, vec2 center, float radius) {\n    float d = distance(uv, center);\n    return 1.0 - smoothstep(radius * 0.8, radius, d);\n}\n\nfloat fbm(vec2 p) {\n    float total = 0.0;\n    float amplitude = 1.0;\n    for (int i = 0; i < 4; i++) {\n        total += noise(p) * amplitude;\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat compute_wave_interference(vec2 uv, float time, float frequency, float time_offset_x, float time_offset_y) {\n    float wave_a = sin((uv.x + time * time_offset_x) * frequency);\n    float wave_b = cos((uv.y + time * time_offset_y) * frequency);\n    return (wave_a * wave_b) * 0.5 + 0.5;\n}\n\nvec2 rotate_uv(vec2 uv, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rotation_matrix = mat2(c, -s, s, c);\n    return rotation_matrix * uv;\n}\n\nfloat mix_waves(float wave1, float wave2, float mix_factor) {\n    return mix(wave1, wave2, mix_factor);\n}\n\n\nvec3 compute_color_operations(float wave_value) {\n    float retro_value = retro_quantize(wave_value, RETRO_LEVELS);\n    return mix_colors(BASE_COLOR, HIGHLIGHT_COLOR, retro_value);\n}\n\nfloat retro_quantize(float value, float levels) {\n    float quantized = floor(value * levels) / levels;\n    return pow(quantized, 2.0);\n}\n\nvec3 mix_colors(vec3 color_a, vec3 color_b, float factor) {\n    return mix(color_a, color_b, factor);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXGBRd",
    "date": "1738468287",
    "viewed": 43,
    "name": "caustic_blobs_reference",
    "description": "caustic blobs attempt (no distortion)",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "water"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifdef __VSCODE__  // Only declare for VS Code linter\nlayout(location = 0) uniform vec3 iResolution;\nlayout(location = 1) uniform float iTime;\nlayout(location = 2) uniform float iTimeDelta;\nlayout(location = 3) uniform int iFrame;\nlayout(location = 4) uniform vec4 iMouse;\n#endif  \n\n#define VIRTUAL_RES_X       256.0   // virtual width in pixels\n#define VIRTUAL_RES_Y       192.0   // virtual height in pixels\n\n#define ZOOM_FACTOR         1.2     // image is magnification value, 1.0 being base 256x192\n\n#define WAVE_FREQUENCY      8.0     //The wave's spatial frequency radians per UV unit \n#define RETRO_LEVELS        4.0     // The number of discrete levels for retro quantization (dimensionless).\n\n#define ANGLE_SPEED_1       0.1     // radians per second\n#define ANGLE_SPEED_2       0.15    // radians per second\n\n#define ANGLE_OFFSET_2      1.0     // radians \n\n// Time multipliers applied before being adding to the UV\n// used to shift the wave computations in the x or y direction (i.e. pixel shift per second)\n#define TIME_OFFSET_X_1     0.3    \n#define TIME_OFFSET_Y_1    -0.3\n#define TIME_OFFSET_X_2    -0.2\n#define TIME_OFFSET_Y_2     0.2\n\n#define BASE_COLOR          vec3(0.0, 0.2, 0.4) \n#define HIGHLIGHT_COLOR     vec3(0.7, 0.9, 1.0)\n\n//pixelates fragments based on provided virtual_res and then zooms with a factor of the virtual_res\nvec2 pixelate_and_zoom_uv(vec2 frag_coord, vec2 resolution, vec2 virtual_resolution, float zoom_factor);\nvec2 pixelate_uv(vec2 uv, vec2 resolution, vec2 virtual_resolution);\nvec2 zoom_uv(vec2 uv, float zoom_factor);\n\n// Computes a combined wave interference pattern using rotations, sine/cosine and iTime offsets\nfloat compute_wave_pattern(vec2 uv, float time, float frequency);\nfloat compute_wave_interference(vec2 uv, float time, float frequency, float time_offset_x, float time_offset_y);\nvec2 rotate_uv(vec2 uv, float angle);\nfloat mix_waves(float wave1, float wave2, float mix_factor);\n\n// Floors a value to a discrete number of levels, then applies a power function: 'levels' is a count of steps\nvec3 compute_color_operations(float wave_value);\nfloat retro_quantize(float value, float levels);\nvec3 mix_colors(vec3 color_a, vec3 color_b, float factor);\n\nfloat compute_wave_pattern_1(vec2 uv, float time, float frequency);\nvec2 distortUV(vec2 uv, float time);\nfloat causticSpot(vec2 uv, vec2 center, float radius);\nfloat fbm(vec2 p);\nfloat noise(vec2 p);\n\n// MAIN SHADERTOY ENTRY FUNCTION\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 final_uv = pixelate_and_zoom_uv(frag_coord, iResolution.xy, vec2(VIRTUAL_RES_X, VIRTUAL_RES_Y), ZOOM_FACTOR);\n    \n    float combined_wave = compute_wave_pattern_1(final_uv, iTime, WAVE_FREQUENCY);\n    \n    vec3 final_color = compute_color_operations(combined_wave);\n    \n    frag_color = vec4(final_color, 1.0);\n}\n\n\nvec2 pixelate_and_zoom_uv(vec2 frag_coord, vec2 resolution, vec2 virtual_resolution, float zoom_factor) {\n    vec2 uv = frag_coord / resolution;\n    vec2 pixelated_uv = pixelate_uv(uv, resolution, virtual_resolution);\n    return zoom_uv(pixelated_uv, zoom_factor);\n}\n\nvec2 pixelate_uv(vec2 uv, vec2 resolution, vec2 virtual_resolution) {\n    vec2 scaled = uv * resolution;\n    vec2 pixelated = floor(scaled * (virtual_resolution / resolution)) / (virtual_resolution / resolution);\n    return pixelated / resolution;\n}\n\nvec2 zoom_uv(vec2 uv, float zoom_factor) {\n    return uv * zoom_factor;\n}\n\n//TODO: This is where to start next time, focus on the blobs/caustic spots, these look promising\nfloat compute_wave_pattern_1(vec2 uv, float time, float frequency) {\n    vec2 distortedUV = uv; //distortUV(uv, time);\n    \n    float angle1 = time * ANGLE_SPEED_1;\n    vec2 rotated_uv1 = rotate_uv(distortedUV, angle1);\n    float wave_pattern_1 = compute_wave_interference(rotated_uv1, time, frequency, TIME_OFFSET_X_1, TIME_OFFSET_Y_1);\n\n    float angle2 = time * ANGLE_SPEED_2 + ANGLE_OFFSET_2;\n    vec2 rotated_uv2 = rotate_uv(distortedUV, angle2);\n    float wave_pattern_2 = compute_wave_interference(rotated_uv2, time, frequency, TIME_OFFSET_X_2, TIME_OFFSET_Y_2);\n\n    float base_wave = mix_waves(wave_pattern_1, wave_pattern_2, 0.5);\n    \n    float blobEffect = 0.0;\n    vec2 center1 = vec2(fract(sin(time + 1.0)*1.0), fract(cos(time + 1.0)*1.0));\n    vec2 center2 = vec2(fract(sin(time + 2.0)*1.0), fract(cos(time + 2.0)*1.0));\n    blobEffect += causticSpot(distortedUV, center1, 0.1);\n    blobEffect += causticSpot(distortedUV, center2, 0.12);\n    blobEffect = clamp(blobEffect, 0.0, 1.0);\n    \n    float finalPattern = mix(base_wave, blobEffect, 0.3);\n    \n    finalPattern = step(0.5, finalPattern);\n    \n    return finalPattern;\n}\n\nvec2 distortUV(vec2 uv, float time) {\n    float offsetX = fbm(uv * 2.0 + time * 0.1) * 0.05;\n    float offsetY = fbm(uv * 2.0 - time * 0.1) * 0.05;\n    return uv + vec2(offsetX, offsetY);\n}\n\nfloat causticSpot(vec2 uv, vec2 center, float radius) {\n    float d = distance(uv, center);\n    return 1.0 - smoothstep(radius * 0.8, radius, d);\n}\n\nfloat fbm(vec2 p) {\n    float total = 0.0;\n    float amplitude = 1.0;\n    for (int i = 0; i < 4; i++) {\n        total += noise(p) * amplitude;\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat compute_wave_interference(vec2 uv, float time, float frequency, float time_offset_x, float time_offset_y) {\n    float wave_a = sin((uv.x + time * time_offset_x) * frequency);\n    float wave_b = cos((uv.y + time * time_offset_y) * frequency);\n    return (wave_a * wave_b) * 0.5 + 0.5;\n}\n\nvec2 rotate_uv(vec2 uv, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rotation_matrix = mat2(c, -s, s, c);\n    return rotation_matrix * uv;\n}\n\nfloat mix_waves(float wave1, float wave2, float mix_factor) {\n    return mix(wave1, wave2, mix_factor);\n}\n\n\nvec3 compute_color_operations(float wave_value) {\n    float retro_value = retro_quantize(wave_value, RETRO_LEVELS);\n    return mix_colors(BASE_COLOR, HIGHLIGHT_COLOR, retro_value);\n}\n\nfloat retro_quantize(float value, float levels) {\n    float quantized = floor(value * levels) / levels;\n    return pow(quantized, 2.0);\n}\n\nvec3 mix_colors(vec3 color_a, vec3 color_b, float factor) {\n    return mix(color_a, color_b, factor);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4XKBzt",
    "date": "1738485290",
    "viewed": 91,
    "name": "verbose_caustics_refactor",
    "description": "trying to study more caustics work inspired from https://www.shadertoy.com/view/wdG3Rz and https://www.youtube.com/watch?v=8rCRsOLiO7k\n\nmore about this in the git repo! https://github.com/meisei4/shadertoy\n\nstill studying but i feel better about this!!\n\n",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "water"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rn",
       "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//study of caustics work inspired from https://www.shadertoy.com/view/wdG3Rz and https://www.youtube.com/watch?v=8rCRsOLiO7k\n\n// debug macros\n//#define PIXELATE_UV\n#define SHOW_NOISE_DISP_MAP_1\n#define SHOW_NOISE_DISP_MAP_2\n#define SHOW_CAUSTICS_DISP_MAP_1\n#define SHOW_CAUSTICS_DISP_MAP_2\n#define SHOW_BACKGROUND\n\nvec4 sample_disp_map(sampler2D tex, vec2 uv, vec2 velocity, vec2 positional_offset, float intensity_factor);\nvec4 sample_background_with_disp_map(sampler2D tex, vec2 uv, vec4 disp_map, float warp_factor); // This best demonstrates fundamental displacement map concept\nfloat compute_effective_opacity(vec4 noise_disp_map_1, vec4 noise_disp_map_2, vec4 caustics_disp_map_1, vec4 caustics_disp_map_2);   \nvec2 scroll_displacement_map(vec2 uv, vec2 velocity, vec2 positional_offset); \nvec2 pixelate_uv(vec2 uv);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord / iResolution.xy;\n    vec4 noise_disp_map_1 = vec4(0.0);\n    vec4 noise_disp_map_2 = vec4(0.0);\n    vec4 caustics_disp_map_1 = vec4(0.0);\n    vec4 caustics_disp_map_2 = vec4(0.0);\n    vec4 background = vec4(0.0);\n\n    #ifdef PIXELATE_UV\n        uv = pixelate_uv(uv);\n    #endif\n\n    #ifdef SHOW_NOISE_DISP_MAP_1\n        noise_disp_map_1 = sample_disp_map(\n            iChannel0, uv, \n            NOISE_DISP_MAP_1_SCROLL_VELOCITY, \n            NOISE_DISP_MAP_1_INITIAL_OFFSET, \n            NOISE_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_NOISE_DISP_MAP_2\n        noise_disp_map_2 = sample_disp_map(\n            iChannel0, uv, \n            NOISE_DISP_MAP_2_SCROLL_VELOCITY, \n            NOISE_DISP_MAP_2_INITIAL_OFFSET, \n            NOISE_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_CAUSTICS_DISP_MAP_1\n        caustics_disp_map_1 = sample_disp_map(\n            iChannel2, uv, \n            CAUSTICS_DISP_MAP_1_SCROLL_VELOCITY, \n            ZERO_POSITIONAL_OFFSET, \n            CAUSTICS_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_CAUSTICS_DISP_MAP_2\n        caustics_disp_map_2 = sample_disp_map(\n            iChannel2, uv, \n            CAUSTICS_DISP_MAP_2_SCROLL_VELOCITY, \n            ZERO_POSITIONAL_OFFSET, \n            CAUSTICS_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_BACKGROUND\n        background = sample_background_with_disp_map(\n            iChannel1, uv, \n            noise_disp_map_1, \n            BACKGROUND_DISP_WARP_FACTOR\n        );\n    #endif\n\n    float alpha = compute_effective_opacity(\n        noise_disp_map_1, \n        noise_disp_map_2, \n        caustics_disp_map_1, \n        caustics_disp_map_2\n    );\n\n    frag_color = (noise_disp_map_1 + noise_disp_map_2) * alpha + background;\n}\n\n/*\nCaustic Effect Domain & Displacement Map Sampling Summary:\n\n1. Displacement Map Sampling & Darkening:\n   Each texture pixel is an RGBA vector:\n       ┌─────┐\n       │  R  │\n       │  G  │\n       │  B  │\n       │  A  │\n       └─────┘\n   For our grayscale textures:\n       R = G = B,  A = 1.0,  with R ∈ [0, 1].\n\n   The function sample_disp_map() samples the red channel and applies a darkening (dimming) factor:\n     - For noise maps: fₙ = 0.33, so the effective red value is R_effective = R · 0.33, meaning R_effective ∈ [0, 0.33].\n     - For caustics maps: f_c = 0.22, so the effective red value is R_effective = R · 0.22, meaning R_effective ∈ [0, 0.22].\n\n2. Intensity Calculation per Displacement Map:\n   • Noise Displacement Maps:\n       - Two noise maps are used.\n       - For a given pixel, let:\n           R₁ ∈ [0, 0.33]  (from noise map 1)\n           R₂ ∈ [0, 0.33]  (from noise map 2)\n       - Their combined intensity is:\n           I_noise = R₁ + R₂,  with I_noise ∈ [0, 0.66].\n\n   • Caustics Displacement Maps:\n       - Two caustics maps are used.\n       - For a given pixel, let:\n           C₁ ∈ [0, 0.22]  (from caustics map 1)\n           C₂ ∈ [0, 0.22]  (from caustics map 2)\n       - Their combined intensity is:\n           I_caustics = C₁ + C₂,  with I_caustics ∈ [0, 0.44].\n\n3. Total Intensity & Thresholds:\n   - The overall effective intensity is the sum of noise and caustics contributions:\n         I_total = I_noise + I_caustics,  with I_total ∈ [0, 1.10].\n\n   - This intensity determines the final opacity:\n         • If I_noise > NOISE_DISP_INDUCED_INTENSITY_THRESHOLD (e.g., 0.30), use NORMAL_ALPHA.\n         • If I_total > ALL_DISP_MAP_INDUCED_INTENSITY_THRESHOLD (e.g., 0.75), use FULL_ALPHA.\n         • Otherwise, use BLURRY_ALPHA.\n*/\n\nvec4 sample_disp_map(\n    sampler2D tex, \n    vec2 uv, \n    vec2 velocity, \n    vec2 positional_offset, \n    float intensity_factor\n) {\n    vec2 offset_uv = scroll_displacement_map(uv, velocity, positional_offset);\n    float noise_value = texture(tex, offset_uv).r; // Single-channel (red)\n    float scaled_noise = noise_value * intensity_factor;   // Apply intensity/darkening factor to dim the displacement map (otherwise colors get blown out) \n    return vec4(scaled_noise, scaled_noise, scaled_noise, 1.0);\n}\n\nvec4 sample_background_with_disp_map(\n    sampler2D tex, \n    vec2 uv, \n    vec4 disp_map, \n    float warp_factor\n) {\n    vec2 bg_uv = uv + (disp_map.r * warp_factor);\n    return texture(tex, bg_uv);\n}\n\nfloat compute_effective_opacity(\n    vec4 noise_disp_map_1, \n    vec4 noise_disp_map_2, \n    vec4 caustics_disp_map_1, \n    vec4 caustics_disp_map_2\n) {\n    //pull out the r channels only (everything is grayscaled) for these intensity summations\n    float noise_disp_maps_grayscale_intensity_sum = noise_disp_map_1.r + noise_disp_map_2.r; \n    float all_disp_maps_grayscale_intensity_sum = noise_disp_map_1.r + noise_disp_map_2.r + caustics_disp_map_1.r + caustics_disp_map_2.r;\n    \n    float alpha = BLURRY_ALPHA; // trough\n    \n    if (noise_disp_maps_grayscale_intensity_sum > NOISE_DISP_INDUCED_INTENSITY_THRESHOLD) {\n         alpha = NORMAL_ALPHA; // incline towards a peak\n    }\n    if (all_disp_maps_grayscale_intensity_sum > ALL_DISP_MAP_INDUCED_INTENSITY_THRESHOLD) {\n         alpha = FULL_ALPHA; // peak\n    }\n   return alpha;\n}\n\nvec2 scroll_displacement_map(vec2 uv, vec2 velocity, vec2 positional_offset) {\n    return uv + iTime * velocity + positional_offset;\n}\n\nvec2 pixelate_uv(vec2 uv) { \n    return floor(uv * vec2(VIRTUAL_DS_RES_X, VIRTUAL_DS_RES_Y)) / vec2(VIRTUAL_DS_RES_X, VIRTUAL_DS_RES_Y); \n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#ifndef CONSTS_GLSL\n#define CONSTS_GLSL\n\n#define VIRTUAL_DS_RES_X 256.0 // Virtual display resolution width for DS resolution; recommended range: 128.0–1024.0.\n#define VIRTUAL_DS_RES_Y 192.0 // Virtual display resolution height for DS resolution; recommended range: 128.0–1024.0.\n\n#define ZERO_POSITIONAL_OFFSET          vec2(0.0, 0.0)  // No offset\n#define NOISE_DISP_MAP_1_INITIAL_OFFSET vec2(-0.1, 0.0) // Initial offset for noise map 1; small values ([-1.0, 1.0]) yield subtle movement.\n#define NOISE_DISP_MAP_2_INITIAL_OFFSET vec2( 0.1, 0.0) // Initial offset for noise map 2; small values ([-1.0, 1.0]) yield subtle movement.\n\n#define NOISE_DISP_MAP_1_SCROLL_VELOCITY vec2( 0.02,  0.02) // Scrolling velocity for noise map 1; recommended per component: [-0.1, 0.1] for natural motion.\n#define NOISE_DISP_MAP_2_SCROLL_VELOCITY vec2(-0.02, -0.02) // Scrolling velocity for noise map 2; recommended per component: [-0.1, 0.1] for natural motion.\n\n#define CAUSTICS_DISP_MAP_1_SCROLL_VELOCITY vec2(-0.1,  0.01) // Scrolling velocity for caustics map 1; horizontal: [-0.2, 0.2], vertical: [-0.1, 0.1].\n#define CAUSTICS_DISP_MAP_2_SCROLL_VELOCITY vec2( 0.1,  0.01) // Scrolling velocity for caustics map 2; horizontal: [-0.2, 0.2], vertical: [-0.1, 0.1].\n\n#define NOISE_DISP_MAP_DIMMING_FACTOR    0.33 // dims the noise texture -> maximum brightness becomes 1/3 where raw = 1.0 (would be white)\n#define CAUSTICS_DISP_MAP_DIMMING_FACTOR 0.22 // dims the caustics texture -> maximum brightness becomes 2/9 where raw = 1.0 (would be white)\n#define BACKGROUND_DISP_WARP_FACTOR      0.05 // simple warp factor for applying displacement map to background texture\n\n#define BLURRY_ALPHA 0.4 // 40% opacity -> grey overtone (trough areas surrounding the inclining undulations)\n#define NORMAL_ALPHA 0.0 // effectively the dark inclines in a wave undulation\n#define FULL_ALPHA   4.0 // blast the fuck out of all 4 displacement maps 400% opacity -> white (catching the light at the undulation peaks)\n\n#define NOISE_DISP_INDUCED_INTENSITY_THRESHOLD   0.30 // when noise displacement maps effect > 0.3, show water effect at normal alpha\n#define ALL_DISP_MAP_INDUCED_INTENSITY_THRESHOLD 0.75 // when all_brightness > 0.75, show white full alpha\n#endif\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfsSzs",
    "date": "1741235820",
    "viewed": 62,
    "name": "caustics_with_mouse_input_ripple",
    "description": "current draft of water effect",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "water",
     "caustics",
     "ripple"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rn",
       "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// debug macros\n#define PIXELATE_UV\n#define SHOW_NOISE_DISP_MAP_1\n#define SHOW_NOISE_DISP_MAP_2\n#define SHOW_CAUSTICS_DISP_MAP_1\n#define SHOW_CAUSTICS_DISP_MAP_2\n#define SHOW_BACKGROUND\n#define RIPPLE_EFFECT\n\nvec4 sample_disp_map(sampler2D tex, vec2 uv, vec2 velocity, vec2 positional_offset, float intensity_factor);\nvec4 sample_background_with_disp_map(sampler2D tex, vec2 uv, vec4 disp_map, float warp_factor);\nvec2 compute_ripple_offset(vec2 uv);\nfloat compute_effective_opacity(vec4 noise_disp_map_1, vec4 noise_disp_map_2, vec4 caustics_disp_map_1, vec4 caustics_disp_map_2);   \nvec2 scroll_displacement_map(vec2 uv, vec2 velocity, vec2 positional_offset); \nvec2 pixelate_uv(vec2 uv);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord / iResolution.xy;\n    vec4 noise_disp_map_1 = vec4(0.0);\n    vec4 noise_disp_map_2 = vec4(0.0);\n    vec4 caustics_disp_map_1 = vec4(0.0);\n    vec4 caustics_disp_map_2 = vec4(0.0);\n    vec4 background = vec4(0.0);\n\n    #ifdef PIXELATE_UV\n        uv = pixelate_uv(uv);\n    #endif\n\n    #ifdef RIPPLE_EFFECT\n        uv += compute_ripple_offset(uv);\n    #endif\n\n    #ifdef SHOW_NOISE_DISP_MAP_1\n        noise_disp_map_1 = sample_disp_map(\n            iChannel0, uv, \n            NOISE_DISP_MAP_1_SCROLL_VELOCITY, \n            NOISE_DISP_MAP_1_INITIAL_OFFSET, \n            NOISE_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_NOISE_DISP_MAP_2\n        noise_disp_map_2 = sample_disp_map(\n            iChannel0, uv, \n            NOISE_DISP_MAP_2_SCROLL_VELOCITY, \n            NOISE_DISP_MAP_2_INITIAL_OFFSET, \n            NOISE_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_CAUSTICS_DISP_MAP_1\n        caustics_disp_map_1 = sample_disp_map(\n            iChannel2, uv, \n            CAUSTICS_DISP_MAP_1_SCROLL_VELOCITY, \n            ZERO_POSITIONAL_OFFSET, \n            CAUSTICS_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_CAUSTICS_DISP_MAP_2\n        caustics_disp_map_2 = sample_disp_map(\n            iChannel2, uv, \n            CAUSTICS_DISP_MAP_2_SCROLL_VELOCITY, \n            ZERO_POSITIONAL_OFFSET, \n            CAUSTICS_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_BACKGROUND\n        //basic dicplacement map integration\n        background = sample_background_with_disp_map(iChannel1, uv, noise_disp_map_1, BACKGROUND_DISP_WARP_FACTOR);\n    #endif\n\n    float alpha = compute_effective_opacity(\n        noise_disp_map_1, \n        noise_disp_map_2, \n        caustics_disp_map_1, \n        caustics_disp_map_2\n    );\n\n    frag_color = (noise_disp_map_1 + noise_disp_map_2) * alpha + background;\n}\n\nvec4 sample_disp_map(\n    sampler2D tex, \n    vec2 uv, \n    vec2 velocity, \n    vec2 positional_offset, \n    float intensity_factor\n) {\n    vec2 offset_uv = scroll_displacement_map(uv, velocity, positional_offset);\n    float noise_value = texture(tex, offset_uv).r; // Single-channel (red)\n    float scaled_noise = noise_value * intensity_factor;   // Apply intensity/darkening factor to dim the displacement map (otherwise colors get blown out) \n    return vec4(scaled_noise, scaled_noise, scaled_noise, 1.0);\n}\n\n//BASIC DISPLACEMENT MAP EXAMPLE INTEGRATION WITHOUT SCROLLING\nvec4 sample_background_with_disp_map(\n    sampler2D tex, \n    vec2 uv, \n    vec4 disp_map, \n    float warp_factor\n) {\n    vec2 bg_uv = uv + (disp_map.r * warp_factor);\n    return texture(tex, bg_uv);\n}\n\n//TODO: THESE ARE MAYBE FUN TO FUCK WITH WITH AUDIO INPUT\n#define NORMAL_SAMPLE_OFFSET     0.01 // How far we sample around uv to find local slope\n#define NORMAL_Z_SCALE           1.0  // Multiplier for the Z component in the normal\n#define AIR_REFRACTION_INDEX     1.0     \n#define WATER_REFRACTION_INDEX   1.08      \n#define REFRACTION_INDEX_RATIO   (AIR_REFRACTION_INDEX/ WATER_REFRACTION_INDEX) // For water ~0.75. Try (1.0 / 1.5)=~0.67 (glass), (1.0 / 2.4)=~0.42 (diamond), etc.\n#define INCIDENT_DIRECTION       vec3(0.0, 0.0, -1.0) // \"Camera is looking down\" direction\n\nvec2 compute_ripple_offset(vec2 uv) {\n    // Wave simulation buffer (iChannel3) only stores a single \"height\" channel;\n    // we sample neighbors here to derive slope (dX, dY).\n    // The wave pass might use a different neighbor step (e.g. \"EFFECTIVE_SAMPLE_STEP\");\n    // we choose NORMAL_SAMPLE_OFFSET here purely for rendering normals.\n    float height_center = texture(iChannel3, uv).r;  // Might be unused if we only use neighbors\n    float height_left   = texture(iChannel3, uv - vec2(NORMAL_SAMPLE_OFFSET, 0.0)).r;\n    float height_right  = texture(iChannel3, uv + vec2(NORMAL_SAMPLE_OFFSET, 0.0)).r;\n    float height_up     = texture(iChannel3, uv + vec2(0.0, NORMAL_SAMPLE_OFFSET)).r;\n    float height_down   = texture(iChannel3, uv - vec2(0.0, NORMAL_SAMPLE_OFFSET)).r;\n    float d_x = height_right - height_left;\n    float d_y = height_up    - height_down;\n    // --- 2. Build a 3D normal vector. \n    // Notice we multiply the Z part by NORMAL_Z_SCALE * NORMAL_SAMPLE_OFFSET\n    // so we can control how \"tilted\" the surface is.\n    vec3 raw_normal = vec3(d_x, d_y, NORMAL_Z_SCALE * NORMAL_SAMPLE_OFFSET);\n    vec3 surface_normal = normalize(raw_normal);\n    // --- 3. Refract the \"incident direction\" through this normal\n    vec3 refracted = refract(INCIDENT_DIRECTION, surface_normal, REFRACTION_INDEX_RATIO);\n    return refracted.xy;\n}\n\n// vec4 sample_background_with_height_map(sampler2D background_tex, vec2 uv) {\n//     vec2 bg_uv = uv + refracted_offset;\n//     return texture(background_tex, bg_uv);\n// }\n\nfloat compute_effective_opacity(\n    vec4 noise_disp_map_1, \n    vec4 noise_disp_map_2, \n    vec4 caustics_disp_map_1, \n    vec4 caustics_disp_map_2\n) {\n    //pull out the r channels only (everything is grayscaled) for these intensity summations\n    float noise_disp_maps_grayscale_intensity_sum = noise_disp_map_1.r + noise_disp_map_2.r; \n    float all_disp_maps_grayscale_intensity_sum = noise_disp_map_1.r + noise_disp_map_2.r + caustics_disp_map_1.r + caustics_disp_map_2.r;\n    \n    float alpha = BLURRY_ALPHA; // trough\n    \n    if (noise_disp_maps_grayscale_intensity_sum > NOISE_DISP_INDUCED_INTENSITY_THRESHOLD) {\n         alpha = NORMAL_ALPHA; // incline towards a peak\n    }\n    if (all_disp_maps_grayscale_intensity_sum > ALL_DISP_MAP_INDUCED_INTENSITY_THRESHOLD) {\n         alpha = FULL_ALPHA; // peak\n    }\n   return alpha;\n}\n\nvec2 scroll_displacement_map(vec2 uv, vec2 velocity, vec2 positional_offset) {\n    return uv + iTime * velocity + positional_offset;\n}\n\nvec2 pixelate_uv(vec2 uv) { \n    return floor(uv * vec2(VIRTUAL_DS_RES_X, VIRTUAL_DS_RES_Y)) / vec2(VIRTUAL_DS_RES_X, VIRTUAL_DS_RES_Y); \n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//IDEAL ADJUSTABLE PARAMETERS:\n//EFFECTIVE DOMAIN: [0.5, 20.0] UNITS: multiplier against base 1.0 size (percentage of screen resolution)\n#define RIPPLE_SCALE 0.25 // to scale the size of the ripple\n//EFFECTIVE DOMAIN: [0.1, 1.0] UNITS: multiplier against base 1x speed\n#define SPEED_FACTOR 1.0 // to slow down ripple\n//EFFECTIVE DOMAIN: [-0.34, 1.0] TRY -0.34 to break things,\n#define PROPAGATION_INTENSITY -0.1 //to speed up the ripple\n//EFFECTIVE DOMAIN: [0.025, 0.5], UNITS: percentage of canvas resolution\n#define IMPULSE_WAVE_WIDTH 0.025 //to adjust the wave front width\n\n//BASE PARAMETERS:\n#define BASE_SAMPLE_STEP 0.005\n#define BASE_IMPULSE_STRENGTH -0.015 // Base impulse strength (height units per frame)\n#define BASE_PROPAGATION 1.0 // EFFECTIVE_PROPAGATION to vary between 1.0 and 1.15,\n// TODO: tie this with the advent\n#define BASE_DAMPENING 0.80 // EFFECTIVE_DAMPENING to vary between 95% and 15% of 95%\n\n//EFFECTIVE PARAMETERS DERVIED FROM IDEAL PARAMETERS AND BASE PARAMETERS:\n#define EFFECTIVE_SAMPLE_STEP (BASE_SAMPLE_STEP * SPEED_FACTOR)  \n#define EFFECTIVE_RIPPLE_SCALE (RIPPLE_SCALE / sqrt(SPEED_FACTOR))\n#define IMPULSE_INNER_RADIUS  (0.025 * EFFECTIVE_RIPPLE_SCALE)\n#define IMPULSE_OUTER_RADIUS (IMPULSE_INNER_RADIUS + IMPULSE_WAVE_WIDTH * EFFECTIVE_RIPPLE_SCALE)\n#define EFFECTIVE_PROPAGATION (BASE_PROPAGATION + 0.15 * PROPAGATION_INTENSITY)  // Ranges from 1.0 to 1.15.\n#define EFFECTIVE_DAMPENING (BASE_DAMPENING - 0.15 * PROPAGATION_INTENSITY) // Ranges from 95% down to 15% of 95%\n\nfloat sample_height(sampler2D tex, vec2 uv);\nfloat compute_wavefront(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position);\nfloat distance_to_line_segment(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position);\nfloat compute_line_impulse(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position);\nfloat compute_combined_impulse(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {    \n    vec2 uv = frag_coord / iResolution.xy;\n    // Adjust the y sample offset to compensate for non-square resolutions.\n    // Without this, a fixed UV step would correspond to different pixel distances in x and y,\n    // resulting in anisotropic (e.g. elliptical) ripples.\n    float adjusted_sample_step = EFFECTIVE_SAMPLE_STEP * (iResolution.x / iResolution.y);\n    vec2 neighbor_offset_x = vec2(EFFECTIVE_SAMPLE_STEP, 0.0);\n    vec2 neighbor_offset_y = vec2(0.0, adjusted_sample_step);\n    // Retrieve previous frame height data:\n    //   prev_height: height from 1 frame ago (red channel)\n    //   prev_prev_height: height from 2 frames ago (green channel)\n    vec2 prev_heights = texture(iChannel0, uv).rg;\n    float height_left   = sample_height(iChannel0, uv - neighbor_offset_x);\n    float height_right  = sample_height(iChannel0, uv + neighbor_offset_x);\n    float height_bottom = sample_height(iChannel0, uv - neighbor_offset_y);\n    float height_top    = sample_height(iChannel0, uv + neighbor_offset_y);\n    \n    vec2 mouse_position = iMouse.xy / iResolution.xy;\n    vec2 prev_mouse_position = texture(iChannel0, uv).ba;\n    float mouse_impulse = 0.0;\n    float wake_smoaothing_factor = 0.0;\n    \n    if (iMouse.z > 0.0) {\n        //BASIC\n        float uv_distance_from_mouse = length(mouse_position - uv);\n        //mouse_impulse = BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, uv_distance_from_mouse);\n        \n        //WAVEFRONT ONLY\n        mouse_impulse = compute_wavefront(uv, mouse_position, prev_mouse_position);\n        \n        //LINE PULSE ONLY\n        //mouse_impulse = compute_line_impulse(uv, mouse_position, prev_mouse_position);  \n        //LINE AND WAVEFRONT merge attempt\n        //mouse_impulse = compute_combined_impulse(uv, mouse_position, prev_mouse_position);\n    }\n\n    float avg_neighbor_height = (height_left + height_right + height_top + height_bottom) / 4.0;\n    float new_height = prev_heights.r + EFFECTIVE_PROPAGATION * (avg_neighbor_height - prev_heights.g);\n    new_height *= EFFECTIVE_DAMPENING;\n    new_height += mouse_impulse;\n    \n    vec2 gradient = vec2(height_right - height_left, height_top - height_bottom);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float advection = 0.0;\n    if (length(mouse_velocity) > 0.0001) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        advection = dot(mouse_direction, gradient);\n    }\n    //TODO: MAKE THIS SCALE WITH THE DAMPENING!!!\n    new_height += -0.075 * advection;\n    frag_color = vec4(new_height, prev_heights.r, mouse_position.x, mouse_position.y);\n}\n\nfloat sample_height(sampler2D tex, vec2 uv) {\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n        return 0.0;\n    return texture(tex, uv).r;\n}\n\nfloat compute_wavefront(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position) {\n    float uv_distance_from_mouse = length(mouse_position - uv);\n    float radial_impulse = BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, uv_distance_from_mouse);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float movement = length(mouse_velocity);\n    float directional_factor = 1.0;\n    \n    if (movement > 0.001) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        vec2 to_fragment = normalize(uv - mouse_position);\n        directional_factor = step(0.0, dot(mouse_direction, to_fragment));\n    }\n    \n    return radial_impulse * directional_factor;\n}\n\n///BELOW IS UNUSED REFERENCES FOR mouse displacement smoothing, if needed\nfloat compute_line_impulse(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position) {\n    float normalized_distance = distance_to_line_segment(uv, mouse_position, prev_mouse_position);\n    return BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, normalized_distance);\n}\n\nfloat distance_to_line_segment(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position) {\n    vec2 mouse_delta = mouse_position - prev_mouse_position;\n    float mouse_delta_squared = dot(mouse_delta, mouse_delta);\n    if (mouse_delta_squared < 0.0025) {\n        return length(uv - prev_mouse_position);\n    }\n    vec2 vector_to_uv = uv - prev_mouse_position;\n    float projection = clamp(dot(vector_to_uv, mouse_delta) / mouse_delta_squared, 0.0, 1.0);\n    vec2 closest_point = prev_mouse_position + projection * mouse_delta;\n    return length(uv - closest_point);\n}\n\nfloat compute_combined_impulse(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position) {\n    float disp_length = length(mouse_position - prev_mouse_position);\n    float wavefront_impulse = compute_wavefront(uv, mouse_position, prev_mouse_position);\n    float stretched_impulse = compute_line_impulse(uv, mouse_position, prev_mouse_position);\n    float blend_factor = smoothstep(0.0, 0.1, disp_length);\n    return mix(wavefront_impulse, stretched_impulse, blend_factor);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#ifndef CONSTS_GLSL\n#define CONSTS_GLSL\n\n//#define USE_VSCODE\n#ifdef USE_VSCODE\n    #iChannel0 \"file://assets/textures/gray_noise_small.png\"  // noise displacement map (red channel)\n    #iChannel1 \"file://assets/textures/rocks.jpg\"             // background texture (full-color)\n    #iChannel2 \"file://assets/textures/pebbles.png\"           // caustics displacement map (red channel)\n#endif\n\n//CAUSTIC CONSTANTS:\n#define VIRTUAL_DS_RES_X 256.0 // Virtual display resolution width for DS resolution; recommended range: 128.0–1024.0.\n#define VIRTUAL_DS_RES_Y 192.0 // Virtual display resolution height for DS resolution; recommended range: 128.0–1024.0.\n\n#define ZERO_POSITIONAL_OFFSET          vec2(0.0, 0.0)  // No offset\n#define NOISE_DISP_MAP_1_INITIAL_OFFSET vec2(-0.1, 0.0) // Initial offset for noise map 1; small values ([-1.0, 1.0]) yield subtle movement.\n#define NOISE_DISP_MAP_2_INITIAL_OFFSET vec2( 0.1, 0.0) // Initial offset for noise map 2; small values ([-1.0, 1.0]) yield subtle movement.\n\n#define NOISE_DISP_MAP_1_SCROLL_VELOCITY vec2( 0.02,  0.02) // Scrolling velocity for noise map 1; recommended per component: [-0.1, 0.1] for natural motion.\n#define NOISE_DISP_MAP_2_SCROLL_VELOCITY vec2(-0.02, -0.02) // Scrolling velocity for noise map 2; recommended per component: [-0.1, 0.1] for natural motion.\n\n#define CAUSTICS_DISP_MAP_1_SCROLL_VELOCITY vec2(-0.1,  0.01) // Scrolling velocity for caustics map 1; horizontal: [-0.2, 0.2], vertical: [-0.1, 0.1].\n#define CAUSTICS_DISP_MAP_2_SCROLL_VELOCITY vec2( 0.1,  0.01) // Scrolling velocity for caustics map 2; horizontal: [-0.2, 0.2], vertical: [-0.1, 0.1].\n\n#define NOISE_DISP_MAP_DIMMING_FACTOR    0.33 // dims the noise texture -> maximum brightness becomes 1/3 where raw = 1.0 (would be white)\n#define CAUSTICS_DISP_MAP_DIMMING_FACTOR 0.22 // dims the caustics texture -> maximum brightness becomes 2/9 where raw = 1.0 (would be white)\n#define BACKGROUND_DISP_WARP_FACTOR      0.05 // simple warp factor for applying height and displacement map to background texture\n\n#define BLURRY_ALPHA 0.4 // 40% opacity -> grey overtone (trough areas surrounding the inclining undulations)\n#define NORMAL_ALPHA 0.0 // effectively the dark inclines in a wave undulation\n#define FULL_ALPHA   4.0 // blast the fuck out of all 4 displacement maps 400% opacity -> white (catching the light at the undulation peaks)\n\n#define NOISE_DISP_INDUCED_INTENSITY_THRESHOLD   0.30 // when noise displacement maps effect > 0.3, show water effect at normal alpha\n#define ALL_DISP_MAP_INDUCED_INTENSITY_THRESHOLD 0.75 // when all_brightness > 0.75, show white full alpha\n#endif\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfXXDS",
    "date": "1741259283",
    "viewed": 31,
    "name": "first audio shader",
    "description": "exploring rhythm visualizations...",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 buffer_output = texture(iChannel0, uv);\n    vec2 history_coord = vec2(0.995, 0.995); // or 0.99, 0.99, etc.\n    vec4 history = texture(iChannel0, history_coord);\n\n    if (uv.x >= EQ_AREA_END_X) {\n        // 1) Smooth over 4 frames:\n        float smoothed = (history.r + history.g + history.b + history.a) / 4.0;\n\n        // 2) Convert amplitude to decibels in [minDB..maxDB], then clamp:\n        float amplitude = clamp(smoothed, 1e-6, 1.0);\n        float dB        = 20.0 * log(amplitude);\n\n        float min_dB         = -44.0;\n        float max_dB         = 0.0;\n        float normalized_DB  = (dB - min_dB) / (max_dB - min_dB);\n        normalized_DB        = clamp(normalized_DB, 0.0, 1.0);\n\n        // 3) Apply an S-curve (logistic) to exaggerate mid-range changes:\n        float alpha   = 35.0; \n        float s_value  = 1.0 / (1.0 + exp(-alpha * (normalized_DB - 0.5)));\n        float bar_height = s_value;\n        fragColor = (uv.y < bar_height) ? WHITE : vec4(0.0);\n    } else {\n        fragColor = buffer_output;\n    }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float compute_audio_amplitude(float frequency_start, float frequency_end, int num_samples);\nvec4 render_eq_bar(float normalized_y, float section_relative_x, int bar_count, float freq_min, float freq_max, int sample_count, vec4 bar_color);\nvec4 render_eq(vec2 uv);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    vec2 history_coord = vec2(0.995, 0.995); // or 0.99, 0.99, etc.\n    vec4 prev = texture(iChannel1, history_coord);\n    // Because we stored: R= current amplitude, G= old R, B= old G, A= old B\n    // last frame, we can now shift to get new history:\n    float current_overall = compute_audio_amplitude(0.0, 1.0, 16);\n    vec4 history = vec4(current_overall, prev.r, prev.g, prev.b);\n    \n    //store history data in the top right fragment of the shader\n    if (uv.x >= 0.99 && uv.y >= 0.99) {\n        // This pixel becomes our \"data storage\" for next frame\n        frag_color = history;\n        return;\n    }\n    \n    if (uv.x < EQ_AREA_END_X) {\n        frag_color = render_eq(uv);\n    }\n}\n\nfloat compute_audio_amplitude(float frequency_start, float frequency_end, int num_samples) {\n    float amplitude_accumulator = 0.0;\n    for (int sample_index = 0; sample_index < num_samples; sample_index++) {\n        float sample_fraction = (float(sample_index) + 0.5) / float(num_samples);\n        float sample_frequency = mix(frequency_start, frequency_end, sample_fraction);\n        amplitude_accumulator += texture(iChannel0, vec2(sample_frequency, 0.0)).r;\n    }\n    return amplitude_accumulator / float(num_samples);\n}\n\nvec4 render_eq_bar(float normalized_y, float section_relative_x, int bar_count, float freq_min, float freq_max, int sample_count, vec4 bar_color) {\n    int bar_index = int(floor(section_relative_x * float(bar_count)));\n    float bar_freq_start = freq_min + (freq_max - freq_min) * (float(bar_index) / float(bar_count));\n    float bar_freq_end   = freq_min + (freq_max - freq_min) * (float(bar_index + 1) / float(bar_count));\n    float bar_amplitude = compute_audio_amplitude(bar_freq_start, bar_freq_end, sample_count);\n    return (normalized_y < bar_amplitude) ? bar_color : vec4(0.0);\n}\n\nvec4 render_eq(vec2 uv) {\n    float bass_end_x = EQ_AREA_START_X + EQ_AREA_WIDTH * BASS_RATIO;\n    float mid_start_x = bass_end_x;\n    float mid_end_x = mid_start_x + EQ_AREA_WIDTH * MID_RATIO;\n    float treble_start_x = mid_end_x;\n    float treble_end_x = EQ_AREA_END_X;\n    \n    if (uv.x < bass_end_x) {\n        float section_relative_x = (uv.x - EQ_AREA_START_X) / (bass_end_x - EQ_AREA_START_X);\n        return render_eq_bar(uv.y, section_relative_x, BASS_BAR_COUNT, BASS_FREQ_MIN, BASS_FREQ_MAX, BASS_SAMPLE_COUNT, RED);\n    } else if (uv.x < mid_end_x) {\n        float section_relative_x = (uv.x - mid_start_x) / (mid_end_x - mid_start_x);\n        return render_eq_bar(uv.y, section_relative_x, MID_BAR_COUNT, MID_FREQ_MIN, MID_FREQ_MAX, MID_SAMPLE_COUNT, GREEN);\n    } else {\n        float section_relative_x = (uv.x - treble_start_x) / (treble_end_x - treble_start_x);\n        return render_eq_bar(uv.y, section_relative_x, TREBLE_BAR_COUNT, TREBLE_FREQ_MIN, TREBLE_FREQ_MAX, TREBLE_SAMPLE_COUNT, BLUE);\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "const int BASS_BAR_COUNT      = 128;\nconst int BASS_SAMPLE_COUNT   = 16;\nconst int MID_BAR_COUNT       = 128;\nconst int MID_SAMPLE_COUNT    = 16;\nconst int TREBLE_BAR_COUNT    = 128;\nconst int TREBLE_SAMPLE_COUNT = 16;\nconst float EQ_AREA_START_X   = 0.0;\nconst float EQ_AREA_END_X     = 0.9;\nconst float EQ_AREA_WIDTH     = EQ_AREA_END_X - EQ_AREA_START_X;\nconst float BASS_RATIO        = 0.33;\nconst float MID_RATIO         = 0.33;\nconst float TREBLE_RATIO      = 0.34;\n\nconst float BASS_FREQ_MIN     = 0.00;\nconst float BASS_FREQ_MAX     = 0.10;\nconst float MID_FREQ_MIN      = 0.10;\nconst float MID_FREQ_MAX      = 0.40;\nconst float TREBLE_FREQ_MIN   = 0.40;\nconst float TREBLE_FREQ_MAX   = 1.0;\n\nconst vec4 RED    = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 GREEN  = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 BLUE   = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 WHITE  = vec4(1.0, 1.0, 1.0, 1.0);\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tffXDj",
    "date": "1741320983",
    "viewed": 50,
    "name": "audio effect on ripples",
    "description": "audio test!",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "ripples",
     "water",
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 compute_ripple_offset(vec2 uv);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord / iResolution.xy;\n    vec2 rippled_uv = compute_ripple_offset(uv);\n    frag_color = texture(iChannel0, rippled_uv);\n}\n\n#define NORMAL_SAMPLE_OFFSET     0.001 // How far we sample around uv to find local slope\n#define NORMAL_Z_SCALE           1.0  // Multiplier for the Z component in the normal\n#define AIR_REFRACTION_INDEX     1.0     \n#define WATER_REFRACTION_INDEX   1.08      \n#define REFRACTION_INDEX_RATIO   (AIR_REFRACTION_INDEX/ WATER_REFRACTION_INDEX) // For water ~0.75. Try (1.0 / 1.5)=~0.67 (glass), (1.0 / 2.4)=~0.42 (diamond), etc.\n#define INCIDENT_DIRECTION       vec3(0.0, 0.0, -1.0) // \"Camera is looking down\" direction\n\nvec2 compute_ripple_offset(vec2 uv) {\n    float height_left   = texture(iChannel1, uv - vec2(NORMAL_SAMPLE_OFFSET, 0.0)).r;\n    float height_right  = texture(iChannel1, uv + vec2(NORMAL_SAMPLE_OFFSET, 0.0)).r;\n    float height_up     = texture(iChannel1, uv + vec2(0.0, NORMAL_SAMPLE_OFFSET)).r;\n    float height_down   = texture(iChannel1, uv - vec2(0.0, NORMAL_SAMPLE_OFFSET)).r;\n    float d_x = height_right - height_left;\n    float d_y = height_up    - height_down;\n\n    vec3 raw_normal = vec3(d_x, d_y, NORMAL_Z_SCALE * NORMAL_SAMPLE_OFFSET);\n    vec3 surface_normal = normalize(raw_normal);\n    \n    vec3 refracted = refract(INCIDENT_DIRECTION, surface_normal, REFRACTION_INDEX_RATIO);\n    return uv + refracted.xy;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//IDEAL ADJUSTABLE PARAMETERS:\n//EFFECTIVE DOMAIN: [0.5, 20.0] UNITS: multiplier against base 1.0 size (percentage of screen resolution)\n#define RIPPLE_SCALE 0.20 // to scale the size of the ripple\n//EFFECTIVE DOMAIN: [0.1, 1.0] UNITS: multiplier against base 1x speed\n#define SPEED_FACTOR 1.0 // to slow down ripple\n//EFFECTIVE DOMAIN: [-0.34, 1.0] TRY -0.34 to break things,\n#define PROPAGATION_INTENSITY -0.0 //to speed up the ripple\n//EFFECTIVE DOMAIN: [0.025, 0.5], UNITS: percentage of canvas resolution\n#define IMPULSE_WAVE_WIDTH 0.025 //to adjust the wave front width\n\n//BASE PARAMETERS:\n#define BASE_SAMPLE_STEP 0.005\n#define BASE_IMPULSE_STRENGTH -0.015 // Base impulse strength (height units per frame)\n#define BASE_PROPAGATION 1.0 // EFFECTIVE_PROPAGATION to vary between 1.0 and 1.15,\n// TODO: tie this with the advent\n#define BASE_DAMPENING 0.80 // EFFECTIVE_DAMPENING to vary between 95% and 15% of 95%\n\n//EFFECTIVE PARAMETERS DERVIED FROM IDEAL PARAMETERS AND BASE PARAMETERS:\n#define EFFECTIVE_SAMPLE_STEP (BASE_SAMPLE_STEP * SPEED_FACTOR)  \n#define EFFECTIVE_RIPPLE_SCALE (RIPPLE_SCALE / sqrt(SPEED_FACTOR))\n#define IMPULSE_INNER_RADIUS  (0.025 * EFFECTIVE_RIPPLE_SCALE)\n#define IMPULSE_OUTER_RADIUS (IMPULSE_INNER_RADIUS + IMPULSE_WAVE_WIDTH * EFFECTIVE_RIPPLE_SCALE)\n#define EFFECTIVE_PROPAGATION (BASE_PROPAGATION + 0.15 * PROPAGATION_INTENSITY)  // Ranges from 1.0 to 1.15.\n#define EFFECTIVE_DAMPENING (BASE_DAMPENING - 0.15 * PROPAGATION_INTENSITY) // Ranges from 95% down to 15% of 95%\n\nfloat sample_height(sampler2D tex, vec2 uv);\nfloat compute_wavefront(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position);\nfloat get_audio_scale_factor();\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {    \n    \n    vec2 uv = frag_coord / iResolution.xy;\n    // Adjust the y sample offset to compensate for non-square resolutions.\n    // Without this, a fixed UV step would correspond to different pixel distances in x and y,\n    // resulting in anisotropic (e.g. elliptical) ripples.\n    float adjusted_sample_step = EFFECTIVE_SAMPLE_STEP * (iResolution.x / iResolution.y);\n    vec2 neighbor_offset_x = vec2(EFFECTIVE_SAMPLE_STEP, 0.0);\n    vec2 neighbor_offset_y = vec2(0.0, adjusted_sample_step);\n    // Retrieve previous frame height data:\n    //   prev_height: height from 1 frame ago (red channel)\n    //   prev_prev_height: height from 2 frames ago (green channel)\n    vec2 prev_heights = texture(iChannel0, uv).rg;\n    float height_left   = sample_height(iChannel0, uv - neighbor_offset_x);\n    float height_right  = sample_height(iChannel0, uv + neighbor_offset_x);\n    float height_bottom = sample_height(iChannel0, uv - neighbor_offset_y);\n    float height_top    = sample_height(iChannel0, uv + neighbor_offset_y);\n    \n    vec2 mouse_position = iMouse.xy / iResolution.xy;\n    vec2 prev_mouse_position = texture(iChannel0, uv).ba;\n    float mouse_impulse = 0.0;\n    \n    if (iMouse.z > 0.0) {\n        //BASIC\n        float uv_distance_from_mouse = length(mouse_position - uv);\n        //mouse_impulse = BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, uv_distance_from_mouse);\n        \n        //WAVEFRONT ONLY\n        mouse_impulse = compute_wavefront(uv, mouse_position, prev_mouse_position);\n        \n        //LINE PULSE ONLY\n        //mouse_impulse = compute_line_impulse(uv, mouse_position, prev_mouse_position);  \n        //LINE AND WAVEFRONT merge attempt\n        //mouse_impulse = compute_combined_impulse(uv, mouse_position, prev_mouse_position);\n    }\n    float avg_neighbor_height = (height_left + height_right + height_top + height_bottom) / 4.0;\n    float new_height = prev_heights.r + EFFECTIVE_PROPAGATION * (avg_neighbor_height - prev_heights.g);\n    new_height *= EFFECTIVE_DAMPENING;\n    new_height += mouse_impulse;\n    \n    vec2 gradient = vec2(height_right - height_left, height_top - height_bottom);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float advection = 0.0;\n    if (length(mouse_velocity) > 0.0001) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        advection = dot(mouse_direction, gradient);\n    }\n    //TODO: MAKE THIS SCALE WITH THE DAMPENING!!!\n    new_height += -0.075 * advection;\n    frag_color = vec4(new_height, prev_heights.r, mouse_position.x, mouse_position.y);\n}\n\nfloat sample_height(sampler2D tex, vec2 uv) {\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n        return 0.0;\n    return texture(tex, uv).r;\n}\n\nfloat compute_wavefront(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position) {\n    float uv_distance_from_mouse = length(mouse_position - uv);\n    float audio_factor = get_audio_scale_factor();\n    float audio_effective_inner_radius = IMPULSE_INNER_RADIUS * audio_factor;\n    float audio_effective_outer_radius = IMPULSE_OUTER_RADIUS * audio_factor;\n    float radial_impulse = audio_factor * BASE_IMPULSE_STRENGTH * smoothstep(audio_effective_outer_radius, audio_effective_inner_radius, uv_distance_from_mouse);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float movement = length(mouse_velocity);\n    float directional_factor = 1.0;\n    \n    if (movement > 0.001) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        vec2 to_fragment = normalize(uv - mouse_position);\n        directional_factor = step(0.0, dot(mouse_direction, to_fragment));\n    }\n    \n    return radial_impulse * directional_factor;\n}\n\nfloat get_audio_scale_factor(){\n    vec2 history_coord = vec2(0.995, 0.995); //JESUS THIS IS INSANE\n    vec4 rhythm_heights = texture(iChannel1, history_coord);\n    float smoothed = (rhythm_heights.r + rhythm_heights.g + rhythm_heights.b + rhythm_heights.a) / 4.0;\n    float amplitude = clamp(smoothed, 1e-6, 1.0);\n    float dB        = 20.0 * log(amplitude);\n    float min_dB         = -45.0;\n    float max_dB         = 0.0;\n    float normalized_DB  = (dB - min_dB) / (max_dB - min_dB);\n    normalized_DB        = clamp(normalized_DB, 0.0, 1.0);\n    float alpha   = 40.0; \n    float s_value  = 1.0 / (1.0 + exp(-alpha * (normalized_DB - 0.5)));\n    float bar_height = s_value;\n\n    // We want f(0.75)=4 => Solve B^0.75=4 => B=4^(1/0.75)= about 6.349\n    float B = 6.349;  \n    return pow(B, bar_height);  // Then factor(0.75)=4\n    // That means factor(1.0)=6.349, factor(0.0)=1.0, etc.}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "const int BASS_BAR_COUNT      = 2;\nconst int BASS_SAMPLE_COUNT   = 16;\nconst int MID_BAR_COUNT       = 8;\nconst int MID_SAMPLE_COUNT    = 16;\nconst int TREBLE_BAR_COUNT    = 32;\nconst int TREBLE_SAMPLE_COUNT = 16;\nconst float EQ_AREA_START_X   = 0.0;\nconst float EQ_AREA_END_X     = 0.9;\nconst float EQ_AREA_WIDTH     = EQ_AREA_END_X - EQ_AREA_START_X;\nconst float BASS_RATIO        = 0.33;\nconst float MID_RATIO         = 0.33;\nconst float TREBLE_RATIO      = 0.34;\n\nconst float BASS_FREQ_MIN     = 0.00;\nconst float BASS_FREQ_MAX     = 0.10;\nconst float MID_FREQ_MIN      = 0.10;\nconst float MID_FREQ_MAX      = 0.40;\nconst float TREBLE_FREQ_MIN   = 0.40;\nconst float TREBLE_FREQ_MAX   = 1.0;\n\nconst vec4 RED    = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 GREEN  = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 BLUE   = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 WHITE  = vec4(1.0, 1.0, 1.0, 1.0);\n\nfloat compute_audio_amplitude(float frequency_start, float frequency_end, int num_samples);\nvec4 render_eq_bar(float normalized_y, float section_relative_x, int bar_count, float freq_min, float freq_max, int sample_count, vec4 bar_color);\nvec4 render_eq(vec2 uv);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalize coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 history_coord = vec2(0.995, 0.995); // or 0.99, 0.99, etc.\n    vec4 prev = texture(iChannel0, history_coord);\n    \n    // Because we stored: R= current amplitude, G= old R, B= old G, A= old B\n    // last frame, we can now shift to get new history:\n    float current_overall = compute_audio_amplitude(0.0, 1.0, 16);\n    vec4 history = vec4(current_overall, prev.r, prev.g, prev.b);\n    \n    //store history data in the top right fragment of the shader\n    if (uv.x >= 0.99 && uv.y >= 0.99) {\n        // This pixel becomes our \"data storage\" for next frame\n        fragColor = history;\n        return;\n    }\n    if (uv.x >= EQ_AREA_END_X) {\n        // 1) Smooth over 4 frames:\n        float smoothed = (history.r + history.g + history.b + history.a) / 4.0;\n\n        // 2) Convert amplitude to decibels in [minDB..maxDB], then clamp:\n        float amplitude = clamp(smoothed, 1e-6, 1.0);\n        float dB        = 20.0 * log(amplitude);\n\n        float min_dB         = -45.0;\n        float max_dB         = 0.0;\n        float normalized_DB  = (dB - min_dB) / (max_dB - min_dB);\n        normalized_DB        = clamp(normalized_DB, 0.0, 1.0);\n\n        // 3) Apply an S-curve (logistic) to exaggerate mid-range changes:\n        float alpha   = 40.0; \n        float s_value  = 1.0 / (1.0 + exp(-alpha * (normalized_DB - 0.5)));\n        float bar_height = s_value;\n        fragColor = (uv.y < bar_height) ? WHITE : vec4(0.0);\n    } else {\n        fragColor = render_eq(uv);\n    }\n}\n\nfloat compute_audio_amplitude(float frequency_start, float frequency_end, int num_samples) {\n    float amplitude_accumulator = 0.0;\n    for (int sample_index = 0; sample_index < num_samples; sample_index++) {\n        float sample_fraction = (float(sample_index) + 0.5) / float(num_samples);\n        float sample_frequency = mix(frequency_start, frequency_end, sample_fraction);\n        amplitude_accumulator += texture(iChannel1, vec2(sample_frequency, 0.0)).r;\n    }\n    return amplitude_accumulator / float(num_samples);\n}\n\nvec4 render_eq_bar(float normalized_y, float section_relative_x, int bar_count, float freq_min, float freq_max, int sample_count, vec4 bar_color) {\n    int bar_index = int(floor(section_relative_x * float(bar_count)));\n    float bar_freq_start = freq_min + (freq_max - freq_min) * (float(bar_index) / float(bar_count));\n    float bar_freq_end   = freq_min + (freq_max - freq_min) * (float(bar_index + 1) / float(bar_count));\n    float bar_amplitude = compute_audio_amplitude(bar_freq_start, bar_freq_end, sample_count);\n    return (normalized_y < bar_amplitude) ? bar_color : vec4(0.0);\n}\n\nvec4 render_eq(vec2 uv) {\n    float bass_end_x = EQ_AREA_START_X + EQ_AREA_WIDTH * BASS_RATIO;\n    float mid_start_x = bass_end_x;\n    float mid_end_x = mid_start_x + EQ_AREA_WIDTH * MID_RATIO;\n    float treble_start_x = mid_end_x;\n    float treble_end_x = EQ_AREA_END_X;\n    \n    if (uv.x < bass_end_x) {\n        float section_relative_x = (uv.x - EQ_AREA_START_X) / (bass_end_x - EQ_AREA_START_X);\n        return render_eq_bar(uv.y, section_relative_x, BASS_BAR_COUNT, BASS_FREQ_MIN, BASS_FREQ_MAX, BASS_SAMPLE_COUNT, RED);\n    } else if (uv.x < mid_end_x) {\n        float section_relative_x = (uv.x - mid_start_x) / (mid_end_x - mid_start_x);\n        return render_eq_bar(uv.y, section_relative_x, MID_BAR_COUNT, MID_FREQ_MIN, MID_FREQ_MAX, MID_SAMPLE_COUNT, GREEN);\n    } else {\n        float section_relative_x = (uv.x - treble_start_x) / (treble_end_x - treble_start_x);\n        return render_eq_bar(uv.y, section_relative_x, TREBLE_BAR_COUNT, TREBLE_FREQ_MIN, TREBLE_FREQ_MAX, TREBLE_SAMPLE_COUNT, BLUE);\n    }\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcSXRz",
    "date": "0",
    "viewed": 0,
    "name": "basic waveform data visualizer",
    "description": "example of how to look at an audio textures y=1 waveform data.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample the audio texture at the given x coordinate.\n    // The y coordinate is set to 1.0 as in your original code.\n    float waveformVal = texture(iChannel0, vec2(uv.x, 1.0)).r;\n    \n    // Map the waveform value to a color gradient:\n    // - 0.0 -> Blue (0,0,1)\n    // - 1.0 -> Red (1,0,0)\n    // Values around 0.5 (silence) will appear purple.\n    vec3 valueColor = vec3(waveformVal, 0.0, 1.0 - waveformVal);\n    \n    // Create a horizontal line at the exact y position of the sample value.\n    // Adjust lineWidth for a thicker or thinner line.\n    float lineWidth = 0.005;\n    float line = 1.0 - smoothstep(0.0, lineWidth, abs(uv.y - waveformVal));\n    \n    // Combine the base gradient with the white line overlay.\n    vec3 finalColor = mix(valueColor, vec3(1.0), line);\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcjSzh",
    "date": "1741592790",
    "viewed": 57,
    "name": "sound envelope godot",
    "description": "dynamic waterfall plot attempt",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "audio",
     "visualizer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//render_mode blend_disabled;\n\n//#include \"res://Resources/Shaders/Audio/audio_plotting.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform sampler2D iChannel0; //samples the output of audio_feedback_envelope\n\n#define LINE_RENDER_MARGIN 0.23        // amount of thickness (in fragment size/single pixel) that surrounds both sides of the wave signal lines\n#define MAX_DISTANCE 1e6               // some stupid number to just initialize the min distance to closest wave signal logic\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n\nconst float line_render_width = 0.75;\n\nfloat get_envelope_from_buffer(int history_row, int bin_index) {\n    float texture_v = 1.0 - (float(history_row) + 0.5) / float(NUMBER_OF_HISTORY_ROWS);\n    float texture_u = (float(bin_index) + 0.5) / float(NUMBER_OF_BINS);\n    return texture(iChannel0, vec2(texture_u, texture_v)).r;\n}\n\n// Offsets a projected envelope coordinate so the full grid is centered on screen.\nvec2 project_centered_envelope(vec3 envelope_coordinate) {\n    vec2 raw_projected_coordinate = project_envelope(envelope_coordinate);\n    vec2 grid_center = compute_envelope_grid_center();\n    vec2 screen_center = iResolution.xy * 0.5;\n    return raw_projected_coordinate + (screen_center - grid_center);\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    float closest_distance = MAX_DISTANCE;\n    \n    // Loop over each history row (each envelope capture).\n    for (int history_row = 0; history_row < NUMBER_OF_HISTORY_ROWS; history_row++) {\n        // Loop over each pair of adjacent bins.\n        for (int bin_index = 0; bin_index < NUMBER_OF_BINS - 1; bin_index++) {\n            float envelope_left = get_envelope_from_buffer(history_row, bin_index);\n            float envelope_right = get_envelope_from_buffer(history_row, bin_index + 1);\n            \n            vec3 envelope_coordinate_left = vec3(float(bin_index), envelope_left, float(history_row));\n            vec3 envelope_coordinate_right = vec3(float(bin_index + 1), envelope_right, float(history_row));\n            \n            vec2 screen_position_left = project_centered_envelope(envelope_coordinate_left);\n            vec2 screen_position_right = project_centered_envelope(envelope_coordinate_right);\n            \n            //float distance_to_wave_line = distance_to_line(FRAGCOORD.xy, screen_position_left, screen_position_right);\n            float distance_to_wave_line = distance_to_line(frag_coord.xy, screen_position_left, screen_position_right);\n\n            closest_distance = min(closest_distance, distance_to_wave_line);\n        }\n    }\n    \n    float intensity = 1.0 - smoothstep(line_render_width, line_render_width * 2.0, closest_distance);\n    frag_color = vec4(vec3(intensity), 1.0);\n    //COLOR = vec4(vec3(intensity), 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//render_mode blend_disabled;\n\n//#include \"res://Resources/Shaders/Audio/audio_plotting.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform int iFrame;\n//uniform sampler2D iChannel0: hint_screen_texture;\n//uniform sampler2D iChannel1; //audio texture\n\n#define WAVEFORM_SAMPLE_COUNT 512\n\n//TODO: turn these into uniforms maybe \nconst float uUpdateInterval = 10.0;    // e.g. 15.0 for more frequent updates.\nconst float uEnvelopeSmoothing = 0.4;    // e.g. 0.3 to 0.5 for moderate smoothing.\n\nconst int samples_per_bin = WAVEFORM_SAMPLE_COUNT / NUMBER_OF_BINS;\n\nfloat sample_waveform_envelope(int bin_index) {\n    float sum_amplitude = 0.0;\n    for (int i = 0; i < samples_per_bin; i++) {\n        float sample_x = (float(bin_index * samples_per_bin + i) + 0.5) / float(WAVEFORM_SAMPLE_COUNT);\n        float sample_value = texture(iChannel1, vec2(sample_x, 1.0)).r;\n        sum_amplitude += abs(sample_value);\n    }\n    return sum_amplitude / float(samples_per_bin);\n}\n\nvec4 shift_envelope_history(vec2 uv_coordinates, float row_height) {\n    return texture(iChannel0, uv_coordinates + vec2(0.0, row_height));\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n\n    float row_height = 1.0 / float(NUMBER_OF_HISTORY_ROWS);\n    \n    if (uv.y < 1.0 - row_height) {\n        frag_color = shift_envelope_history(uv, row_height);\n        //COLOR = shift_envelope_history(uv, row_height);\n    } else {\n        float update_interval = uUpdateInterval; \n        float blend_factor = mod(float(iFrame), update_interval) / update_interval;\n        \n        int bin_index = int(floor(uv.x * float(NUMBER_OF_BINS)));\n        float new_envelope = sample_waveform_envelope(bin_index);\n        float old_envelope = texture(iChannel0, uv).r;\n        \n        float effective_blend = blend_factor * uEnvelopeSmoothing;\n        float blended_envelope = mix(old_envelope, new_envelope, effective_blend);\n        frag_color = vec4(blended_envelope, blended_envelope, blended_envelope, 1.0);\n        //COLOR = vec4(blended_envelope, blended_envelope, blended_envelope, 1.0);\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define NUMBER_OF_BINS 64\n#define NUMBER_OF_HISTORY_ROWS 5\n\nconst float amplitude_scale = 100.0;\nconst float isometric_zoom   = 3.0;\nconst float row_spacing      = 8.0;\n\nvec2 project_envelope(vec3 envelope_coordinate) {\n    float bin_index       = envelope_coordinate.x;\n    float envelope_value  = envelope_coordinate.y;\n    float history_row     = envelope_coordinate.z;\n    float effective_row   = history_row * row_spacing;\n\n    // Isometric projection:\n    //   X = bin_index - effective_row\n    //   Y = (bin_index + effective_row) * 0.5 - envelope_value * amplitude_scale\n    float projected_x = bin_index - effective_row;\n    float projected_y = (bin_index + effective_row) * 0.5 - envelope_value * amplitude_scale;\n    return vec2(projected_x, projected_y) * isometric_zoom;\n}\n\nvec2 compute_envelope_grid_center() {\n    vec2 projected_bottom_left  = project_envelope(vec3(0.0, 0.0, 0.0));\n    vec2 projected_bottom_right = project_envelope(vec3(float(NUMBER_OF_BINS - 1), 0.0, 0.0));\n    vec2 projected_top_left     = project_envelope(vec3(0.0, 1.0, float(NUMBER_OF_HISTORY_ROWS - 1)));\n    vec2 projected_top_right    = project_envelope(vec3(float(NUMBER_OF_BINS - 1), 1.0, float(NUMBER_OF_HISTORY_ROWS - 1)));\n\n    vec2 minimum_corner = min(min(projected_bottom_left, projected_bottom_right),\n                              min(projected_top_left, projected_top_right));\n    vec2 maximum_corner = max(max(projected_bottom_left, projected_bottom_right),\n                              max(projected_top_left, projected_top_right));\n    return (minimum_corner + maximum_corner) * 0.5;\n}\n\nfloat distance_to_line(vec2 pixel_coordinate, vec2 line_start, vec2 line_end) {\n    vec2 line_vector = line_end - line_start;\n    float line_length_squared = dot(line_vector, line_vector);\n    float projection_factor = dot(pixel_coordinate - line_start, line_vector) / line_length_squared;\n    float clamped_projection_factor = clamp(projection_factor, 0.0, 1.0);\n    vec2 closest_point = line_start + clamped_projection_factor * line_vector;\n    return distance(pixel_coordinate, closest_point);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3s3W8",
    "date": "1742983185",
    "viewed": 50,
    "name": "godot does this with viewports",
    "description": "shader in godot style",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "godot"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 UV = frag_coord.xy / iResolution.xy;\n    frag_color = texture(iChannel0, UV);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n\n//uniform sampler2D iChannel0;\n//uniform vec3 iMouse;\n//uniform vec2 iResolution;\nconst float DECAY_FACTOR = 0.975; \n\nconst float CIRCLE_OUTER_RADIUS = 0.08;\nconst float CIRCLE_INNER_RADIUS = 0.06;\nconst vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    vec2 UV = frag_coord.xy / iResolution.xy;\n    vec4 previous_frames_fragment_color = texture(iChannel0, UV);\n    //in godot Limited texture precision (8/16-bit) and purely additive blending can prevent very small values from decaying to zero causing a persistent color burn.\n    //Thus we combine multiplicative decay with a subtractive clamp to force near-zero values to black.\n    vec4 decayed_previous_frames_fragment_color = previous_frames_fragment_color * DECAY_FACTOR;\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    if (iMouse.z > 0.0){\n        float current_fragments_distance_from_moving_circle = distance(UV, mouse_uv);\n        // Create a soft-edged circle using smoothstep.\n        // - If current fragment coordinates are within 13% screen-sized distance to the center of the circle\n        //      - smoothstep returns 1.0 -> full strength mask will be applied to RED\n        // - As the fragment coordinates get more than 13% radius away from the center of the circle towards 15%\n        //      - the normalized multiplier/smoothstep mask [0, 1.0] smoothly fades to 0.0 -> weaker mask applied to RED\n        // - Once a the fragment coordinates are further than 15% radius away\n        //      - smoothstep reaches 0.0 → ZERO strength applied to red, i.e. NO MORE RED\n        float mask_at_circle_edge = smoothstep(CIRCLE_OUTER_RADIUS, CIRCLE_INNER_RADIUS, current_fragments_distance_from_moving_circle);\n        vec4 current_frames_fragment_color = mask_at_circle_edge * RED;\n        // add the decayed value of the previous frames fragment color with the current frames calculated fragment color\n        //COLOR = decayed_previous_frames_fragment_color + current_frames_fragment_color;\n        frag_color = decayed_previous_frames_fragment_color + current_frames_fragment_color;\n    } else { \n        //COLOR = decayed_previous_frames_fragment_color;\n        frag_color = decayed_previous_frames_fragment_color;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n\n//uniform sampler2D iChannel0;\n//uniform vec3 iMouse;\n//uniform vec2 iResolution;\nconst float DECAY_FACTOR = 0.975; \n\nconst float CIRCLE_OUTER_RADIUS = 0.08;\nconst float CIRCLE_INNER_RADIUS = 0.06;\nconst vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    vec2 UV = frag_coord.xy / iResolution.xy;\n    vec4 previous_frames_fragment_color = texture(iChannel0, UV);\n    //in godot Limited texture precision (8/16-bit) and purely additive blending can prevent very small values from decaying to zero causing a persistent color burn.\n    //Thus we combine multiplicative decay with a subtractive clamp to force near-zero values to black.\n    vec4 decayed_previous_frames_fragment_color = previous_frames_fragment_color * DECAY_FACTOR;\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    if (iMouse.z > 0.0){\n        float current_fragments_distance_from_moving_circle = distance(UV, mouse_uv);\n        // Create a soft-edged circle using smoothstep.\n        // - If current fragment coordinates are within 13% screen-sized distance to the center of the circle\n        //      - smoothstep returns 1.0 -> full strength mask will be applied to RED\n        // - As the fragment coordinates get more than 13% radius away from the center of the circle towards 15%\n        //      - the normalized multiplier/smoothstep mask [0, 1.0] smoothly fades to 0.0 -> weaker mask applied to RED\n        // - Once a the fragment coordinates are further than 15% radius away\n        //      - smoothstep reaches 0.0 → ZERO strength applied to red, i.e. NO MORE RED\n        float mask_at_circle_edge = smoothstep(CIRCLE_OUTER_RADIUS, CIRCLE_INNER_RADIUS, current_fragments_distance_from_moving_circle);\n        vec4 current_frames_fragment_color = mask_at_circle_edge * RED;\n        // add the decayed value of the previous frames fragment color with the current frames calculated fragment color\n        //COLOR = decayed_previous_frames_fragment_color + current_frames_fragment_color;\n        frag_color = decayed_previous_frames_fragment_color + current_frames_fragment_color;\n    } else { \n        //COLOR = decayed_previous_frames_fragment_color;\n        frag_color = decayed_previous_frames_fragment_color;\n    }\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXfGRB",
    "date": "1743207580",
    "viewed": 40,
    "name": "godot viewport ripples",
    "description": "godot shader",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "godot"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    frag_color = texture(iChannel0, uv);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n\n//#include \"res://Resources/Shaders/constants.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform vec3 iMouse;\n//uniform sampler2D iChannel0;\n\n//IDEAL ADJUSTABLE PARAMETERS:\n//EFFECTIVE DOMAIN: [0.5, 20.0] UNITS: multiplier against base 1.0 size (percentage of screen resolution)\n#define RIPPLE_SCALE 1.0 // to scale the size of the ripple\n//EFFECTIVE DOMAIN: [0.1, 1.0] UNITS: multiplier against base 1x speed\n#define SPEED_FACTOR 1.0 // to slow down ripple\n//EFFECTIVE DOMAIN: [-0.34, 1.0] TRY -0.34 to break things,\n#define PROPAGATION_INTENSITY -0.0 //to speed up the ripple\n//EFFECTIVE DOMAIN: [0.025, 0.5], UNITS: percentage of canvas resolution\n#define IMPULSE_WAVE_WIDTH 0.025 //to adjust the wave front width\n\n//BASE PARAMETERS:\n#define BASE_SAMPLE_STEP 0.005\n#define BASE_IMPULSE_STRENGTH -0.015 // Base impulse strength (height units per frame)\n#define BASE_PROPAGATION 1.0 // EFFECTIVE_PROPAGATION to vary between 1.0 and 1.15,\n// TODO: tie this with the advent\n#define BASE_DAMPENING 0.95 // EFFECTIVE_DAMPENING to vary between 95% and 15% of 95%\n\n//EFFECTIVE PARAMETERS DERVIED FROM IDEAL PARAMETERS AND BASE PARAMETERS:\n#define EFFECTIVE_SAMPLE_STEP (BASE_SAMPLE_STEP * SPEED_FACTOR)\n#define EFFECTIVE_RIPPLE_SCALE (RIPPLE_SCALE / sqrt(SPEED_FACTOR))\n#define IMPULSE_INNER_RADIUS  (0.025 * EFFECTIVE_RIPPLE_SCALE)\n#define IMPULSE_OUTER_RADIUS (IMPULSE_INNER_RADIUS + IMPULSE_WAVE_WIDTH * EFFECTIVE_RIPPLE_SCALE)\n#define EFFECTIVE_PROPAGATION (BASE_PROPAGATION + 0.15 * PROPAGATION_INTENSITY)  // Ranges from 1.0 to 1.15.\n#define EFFECTIVE_DAMPENING (BASE_DAMPENING - 0.15 * PROPAGATION_INTENSITY) // Ranges from 95% down to 15% of 95%\n\nfloat sample_height(sampler2D tex, vec2 uv) {\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n        return 0.0;\n    return texture(tex, uv).r;\n}\n\nfloat compute_wavefront(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position) {\n    float uv_distance_from_mouse = length(mouse_position - uv);\n    float radial_impulse = BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, uv_distance_from_mouse);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float movement = length(mouse_velocity);\n    float directional_factor = 1.0;\n\n    if (movement > 0.01) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        vec2 to_fragment = normalize(uv - mouse_position);\n        directional_factor = step(0.0, dot(mouse_direction, to_fragment));\n    }\n\n    return radial_impulse * directional_factor;\n}\n\n//void fragment(){\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n    vec2 uv = frag_coord / iResolution.xy;\n    // Adjust the y sample offset to compensate for non-square resolutions.\n    // Without this, a fixed UV step would correspond to different pixel distances in x and y,\n    // resulting in anisotropic (e.g. elliptical) ripples.\n    float adjusted_sample_step = EFFECTIVE_SAMPLE_STEP * (iResolution.x / iResolution.y);\n    vec2 neighbor_offset_x = vec2(EFFECTIVE_SAMPLE_STEP, 0.0);\n    vec2 neighbor_offset_y = vec2(0.0, adjusted_sample_step);\n    // Retrieve previous frame height data:\n    //   prev_height: height from 1 frame ago (red channel)\n    //   prev_prev_height: height from 2 frames ago (green channel)\n    vec2 prev_heights = texture(iChannel0, uv).rg;\n    float height_left   = sample_height(iChannel0, uv - neighbor_offset_x);\n    float height_right  = sample_height(iChannel0, uv + neighbor_offset_x);\n    float height_bottom = sample_height(iChannel0, uv - neighbor_offset_y);\n    float height_top    = sample_height(iChannel0, uv + neighbor_offset_y);\n\n    vec2 mouse_position = iMouse.xy / iResolution.xy;\n    vec2 prev_mouse_position = texture(iChannel0, uv).ba;\n    float mouse_impulse = 0.0;\n    if (iMouse.z > 0.0) {\n        //BASIC\n        float uv_distance_from_mouse = length(mouse_position - uv);\n        //mouse_impulse = BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, uv_distance_from_mouse);\n\n        //WAVEFRONT ONLY\n        mouse_impulse = compute_wavefront(uv, mouse_position, prev_mouse_position);\n    }\n\n    float avg_neighbor_height = (height_left + height_right + height_top + height_bottom) / 4.0;\n    float new_height = prev_heights.r + EFFECTIVE_PROPAGATION * (avg_neighbor_height - prev_heights.g);\n    new_height *= EFFECTIVE_DAMPENING;\n    new_height += mouse_impulse;\n\n    vec2 gradient = vec2(height_right - height_left, height_top - height_bottom);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float advection = 0.0;\n    if (length(mouse_velocity) > 0.0001) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        advection = dot(mouse_direction, gradient);\n    }\n    //TODO: MAKE THIS SCALE WITH THE DAMPENING!!!\n    new_height += 0.05 * advection;\n    frag_color = vec4(new_height, prev_heights.r, mouse_position.x, mouse_position.y);\n    //COLOR = vec4(new_height, prev_heights.r, mouse_position.x, mouse_position.y);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "//TODO: THESE ARE MAYBE FUN TO FUCK WITH WITH AUDIO INPUT\n#define NORMAL_SAMPLE_OFFSET     0.01 // How far we sample around uv to find local slope\n#define NORMAL_Z_SCALE           1.0  // Multiplier for the Z component in the normal\n#define AIR_REFRACTION_INDEX     1.0\n#define WATER_REFRACTION_INDEX   1.08\n#define REFRACTION_INDEX_RATIO (1.0 / 1.333) // from simple version\n//#define REFRACTION_INDEX_RATIO   (AIR_REFRACTION_INDEX/ WATER_REFRACTION_INDEX) // For water ~0.75. Try (1.0 / 1.5)=~0.67 (glass), (1.0 / 2.4)=~0.42 (diamond), etc.\n#define INCIDENT_DIRECTION       vec3(0.0, 0.0, -1.0) // \"Camera is looking down\" direction\n\n//CAUSTIC CONSTANTS:\n#define VIRTUAL_DS_RES_X 256.0 // Virtual display resolution width for DS resolution; recommended range: 128.0–1024.0.\n#define VIRTUAL_DS_RES_Y 192.0// Virtual display resolution height for DS resolution; recommended range: 128.0–1024.0.\n\n#define ZERO_POSITIONAL_OFFSET          vec2(0.0, 0.0)  // No offset\n#define NOISE_DISP_MAP_1_INITIAL_OFFSET vec2(-0.1, 0.0) // Initial offset for noise map 1; small values ([-1.0, 1.0]) yield subtle movement.\n#define NOISE_DISP_MAP_2_INITIAL_OFFSET vec2( 0.1, 0.0) // Initial offset for noise map 2; small values ([-1.0, 1.0]) yield subtle movement.\n\n#define NOISE_DISP_MAP_1_SCROLL_VELOCITY vec2( 0.02,  0.02) // Scrolling velocity for noise map 1; recommended per component: [-0.1, 0.1] for natural motion.\n#define NOISE_DISP_MAP_2_SCROLL_VELOCITY vec2(-0.02, -0.02) // Scrolling velocity for noise map 2; recommended per component: [-0.1, 0.1] for natural motion.\n\n#define CAUSTICS_DISP_MAP_1_SCROLL_VELOCITY vec2(-0.1,  0.01) // Scrolling velocity for caustics map 1; horizontal: [-0.2, 0.2], vertical: [-0.1, 0.1].\n#define CAUSTICS_DISP_MAP_2_SCROLL_VELOCITY vec2( 0.1,  0.01) // Scrolling velocity for caustics map 2; horizontal: [-0.2, 0.2], vertical: [-0.1, 0.1].\n\n#define NOISE_DISP_MAP_DIMMING_FACTOR    0.33 // dims the noise texture -> maximum brightness becomes 1/3 where raw = 1.0 (would be white)\n#define CAUSTICS_DISP_MAP_DIMMING_FACTOR 0.22 // dims the caustics texture -> maximum brightness becomes 2/9 where raw = 1.0 (would be white)\n#define BACKGROUND_DISP_WARP_FACTOR      0.05 // simple warp factor for applying height and displacement map to background texture\n\n#define BLURRY_ALPHA 0.4 // 40% opacity -> grey overtone (trough areas surrounding the inclining undulations)\n#define NORMAL_ALPHA 0.0 // effectively the dark inclines in a wave undulation\n#define FULL_ALPHA   4.0 // blast the fuck out of all 4 displacement maps 400% opacity -> white (catching the light at the undulation peaks)\n\n#define NOISE_DISP_INDUCED_INTENSITY_THRESHOLD   0.30 // when noise displacement maps effect > 0.3, show water effect at normal alpha\n#define ALL_DISP_MAP_INDUCED_INTENSITY_THRESHOLD 0.75 // when all_brightness > 0.75, show white full alpha\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n\n//#include \"res://Resources/Shaders/constants.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform vec3 iMouse;\n//uniform sampler2D iChannel0;\n\n//IDEAL ADJUSTABLE PARAMETERS:\n//EFFECTIVE DOMAIN: [0.5, 20.0] UNITS: multiplier against base 1.0 size (percentage of screen resolution)\n#define RIPPLE_SCALE 1.0 // to scale the size of the ripple\n//EFFECTIVE DOMAIN: [0.1, 1.0] UNITS: multiplier against base 1x speed\n#define SPEED_FACTOR 1.0 // to slow down ripple\n//EFFECTIVE DOMAIN: [-0.34, 1.0] TRY -0.34 to break things,\n#define PROPAGATION_INTENSITY -0.0 //to speed up the ripple\n//EFFECTIVE DOMAIN: [0.025, 0.5], UNITS: percentage of canvas resolution\n#define IMPULSE_WAVE_WIDTH 0.025 //to adjust the wave front width\n\n//BASE PARAMETERS:\n#define BASE_SAMPLE_STEP 0.005\n#define BASE_IMPULSE_STRENGTH -0.015 // Base impulse strength (height units per frame)\n#define BASE_PROPAGATION 1.0 // EFFECTIVE_PROPAGATION to vary between 1.0 and 1.15,\n// TODO: tie this with the advent\n#define BASE_DAMPENING 0.85 // EFFECTIVE_DAMPENING to vary between 95% and 15% of 95%\n\n//EFFECTIVE PARAMETERS DERVIED FROM IDEAL PARAMETERS AND BASE PARAMETERS:\n#define EFFECTIVE_SAMPLE_STEP (BASE_SAMPLE_STEP * SPEED_FACTOR)\n#define EFFECTIVE_RIPPLE_SCALE (RIPPLE_SCALE / sqrt(SPEED_FACTOR))\n#define IMPULSE_INNER_RADIUS  (0.025 * EFFECTIVE_RIPPLE_SCALE)\n#define IMPULSE_OUTER_RADIUS (IMPULSE_INNER_RADIUS + IMPULSE_WAVE_WIDTH * EFFECTIVE_RIPPLE_SCALE)\n#define EFFECTIVE_PROPAGATION (BASE_PROPAGATION + 0.15 * PROPAGATION_INTENSITY)  // Ranges from 1.0 to 1.15.\n#define EFFECTIVE_DAMPENING (BASE_DAMPENING - 0.15 * PROPAGATION_INTENSITY) // Ranges from 95% down to 15% of 95%\n\nfloat sample_height(sampler2D tex, vec2 uv) {\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n        return 0.0;\n    return texture(tex, uv).r;\n}\n\nfloat compute_wavefront(vec2 uv, vec2 mouse_position, vec2 prev_mouse_position) {\n    float uv_distance_from_mouse = length(mouse_position - uv);\n    float radial_impulse = BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, uv_distance_from_mouse);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float movement = length(mouse_velocity);\n    float directional_factor = 1.0;\n\n    if (movement > 0.01) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        vec2 to_fragment = normalize(uv - mouse_position);\n        directional_factor = step(0.0, dot(mouse_direction, to_fragment));\n    }\n\n    return radial_impulse * directional_factor;\n}\n\n//void fragment(){\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n    vec2 uv = frag_coord / iResolution.xy;\n    // Adjust the y sample offset to compensate for non-square resolutions.\n    // Without this, a fixed UV step would correspond to different pixel distances in x and y,\n    // resulting in anisotropic (e.g. elliptical) ripples.\n    float adjusted_sample_step = EFFECTIVE_SAMPLE_STEP * (iResolution.x / iResolution.y);\n    vec2 neighbor_offset_x = vec2(EFFECTIVE_SAMPLE_STEP, 0.0);\n    vec2 neighbor_offset_y = vec2(0.0, adjusted_sample_step);\n    // Retrieve previous frame height data:\n    //   prev_height: height from 1 frame ago (red channel)\n    //   prev_prev_height: height from 2 frames ago (green channel)\n    vec2 prev_heights = texture(iChannel0, uv).rg;\n    float height_left   = sample_height(iChannel0, uv - neighbor_offset_x);\n    float height_right  = sample_height(iChannel0, uv + neighbor_offset_x);\n    float height_bottom = sample_height(iChannel0, uv - neighbor_offset_y);\n    float height_top    = sample_height(iChannel0, uv + neighbor_offset_y);\n\n    vec2 mouse_position = iMouse.xy / iResolution.xy;\n    vec2 prev_mouse_position = texture(iChannel0, uv).ba;\n    float mouse_impulse = 0.0;\n    if (iMouse.z > 0.0) {\n        //BASIC\n        float uv_distance_from_mouse = length(mouse_position - uv);\n        //mouse_impulse = BASE_IMPULSE_STRENGTH * smoothstep(IMPULSE_OUTER_RADIUS, IMPULSE_INNER_RADIUS, uv_distance_from_mouse);\n\n        //WAVEFRONT ONLY\n        mouse_impulse = compute_wavefront(uv, mouse_position, prev_mouse_position);\n    }\n\n    float avg_neighbor_height = (height_left + height_right + height_top + height_bottom) / 4.0;\n    float new_height = prev_heights.r + EFFECTIVE_PROPAGATION * (avg_neighbor_height - prev_heights.g);\n    new_height *= EFFECTIVE_DAMPENING;\n    new_height += mouse_impulse;\n\n    vec2 gradient = vec2(height_right - height_left, height_top - height_bottom);\n    vec2 mouse_velocity = mouse_position - prev_mouse_position;\n    float advection = 0.0;\n    if (length(mouse_velocity) > 0.0001) {\n        vec2 mouse_direction = normalize(mouse_velocity);\n        advection = dot(mouse_direction, gradient);\n    }\n    //TODO: MAKE THIS SCALE WITH THE DAMPENING!!!\n    new_height += -0.06 * advection;\n    frag_color = vec4(new_height, prev_heights.r, mouse_position.x, mouse_position.y);\n    //COLOR = vec4(new_height, prev_heights.r, mouse_position.x, mouse_position.y);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rn",
       "filepath": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n\n//#include \"res://Resources/Shaders/constants.gdshaderinc\"\n//uniform vec2 iResolution;\n//uniform float iTime;\n//uniform sampler2D iChannel0; //\"file://assets/textures/gray_noise_small.png\"  // noise displacement map (red channel)\n//uniform sampler2D iChannel1; //\"file://assets/textures/rocks.jpg\"             // background texture (full-color)\n//uniform sampler2D iChannel2; //\"file://assets/textures/pebbles.png\"           // caustics displacement map (red channel)\n//uniform sampler2D iChannel3; // this should be whats getting updated by buffer\n\n// debug macros\n#define PIXELATE_UV\n#define SHOW_NOISE_DISP_MAP_1\n#define SHOW_NOISE_DISP_MAP_2\n#define SHOW_CAUSTICS_DISP_MAP_1\n#define SHOW_CAUSTICS_DISP_MAP_2\n#define SHOW_BACKGROUND\n#define RIPPLE_EFFECT\n\nvec2 pixelate_uv(vec2 uv) {\n    return floor(uv * vec2(VIRTUAL_DS_RES_X, VIRTUAL_DS_RES_Y)) / vec2(VIRTUAL_DS_RES_X, VIRTUAL_DS_RES_Y);\n}\n\nvec2 scroll_displacement_map(vec2 uv, vec2 velocity, vec2 positional_offset) {\n    return uv + iTime * velocity + positional_offset;\n}\n\nvec4 sample_disp_map(\n    sampler2D tex,\n    vec2 uv,\n    vec2 velocity,\n    vec2 positional_offset,\n    float intensity_factor\n) {\n    vec2 offset_uv = scroll_displacement_map(uv, velocity, positional_offset);\n    float noise_value = texture(tex, offset_uv).r; // Single-channel (red)\n    float scaled_noise = noise_value * intensity_factor;   // Apply intensity/darkening factor to dim the displacement map (otherwise colors get blown out)\n    return vec4(scaled_noise, scaled_noise, scaled_noise, 1.0);\n}\n\n//BASIC DISPLACEMENT MAP EXAMPLE INTEGRATION WITHOUT SCROLLING\nvec4 sample_background_with_disp_map(\n    sampler2D tex,\n    vec2 uv,\n    vec4 disp_map,\n    float warp_factor\n) {\n    vec2 bg_uv = uv + (disp_map.r * warp_factor);\n    return texture(tex, bg_uv);\n}\n\nvec2 compute_ripple_offset(vec2 uv) {\n    // Wave simulation buffer (iChannel3) only stores a single \"height\" channel;\n    // we sample neighbors here to derive slope (dX, dY).\n    // The wave pass might use a different neighbor step (e.g. \"EFFECTIVE_SAMPLE_STEP\");\n    // we choose NORMAL_SAMPLE_OFFSET here purely for rendering normals.\n    float height_center = texture(iChannel3, uv).r;  // Might be unused if we only use neighbors\n    float height_left   = texture(iChannel3, uv - vec2(NORMAL_SAMPLE_OFFSET, 0.0)).r;\n    float height_right  = texture(iChannel3, uv + vec2(NORMAL_SAMPLE_OFFSET, 0.0)).r;\n    float height_up     = texture(iChannel3, uv + vec2(0.0, NORMAL_SAMPLE_OFFSET)).r;\n    float height_down   = texture(iChannel3, uv - vec2(0.0, NORMAL_SAMPLE_OFFSET)).r;\n    float d_x = height_right - height_left;\n    float d_y = height_up    - height_down;\n    // --- 2. Build a 3D normal vector.\n    // Notice we multiply the Z part by NORMAL_Z_SCALE * NORMAL_SAMPLE_OFFSET\n    // so we can control how \"tilted\" the surface is.\n    vec3 raw_normal = vec3(d_x, d_y, NORMAL_Z_SCALE * NORMAL_SAMPLE_OFFSET);\n    vec3 surface_normal = normalize(raw_normal);\n    // --- 3. Refract the \"incident direction\" through this normal\n    vec3 refracted = refract(INCIDENT_DIRECTION, surface_normal, REFRACTION_INDEX_RATIO);\n    return refracted.xy;\n}\n\n// vec4 sample_background_with_height_map(sampler2D background_tex, vec2 uv) {\n//     vec2 bg_uv = uv + refracted_offset;\n//     return texture(background_tex, bg_uv);\n// }\n\nfloat compute_effective_opacity(\n    vec4 noise_disp_map_1,\n    vec4 noise_disp_map_2,\n    vec4 caustics_disp_map_1,\n    vec4 caustics_disp_map_2\n) {\n    //pull out the r channels only (everything is grayscaled) for these intensity summations\n    float noise_disp_maps_grayscale_intensity_sum = noise_disp_map_1.r + noise_disp_map_2.r;\n    float all_disp_maps_grayscale_intensity_sum = noise_disp_map_1.r + noise_disp_map_2.r + caustics_disp_map_1.r + caustics_disp_map_2.r;\n\n    float alpha = BLURRY_ALPHA; // trough\n\n    if (noise_disp_maps_grayscale_intensity_sum > NOISE_DISP_INDUCED_INTENSITY_THRESHOLD) {\n         alpha = NORMAL_ALPHA; // incline towards a peak\n    }\n    if (all_disp_maps_grayscale_intensity_sum > ALL_DISP_MAP_INDUCED_INTENSITY_THRESHOLD) {\n         alpha = FULL_ALPHA; // peak\n    }\n   return alpha;\n}\n\n//void fragment(){\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n    vec2 uv = frag_coord / iResolution.xy;\n\n    vec4 noise_disp_map_1 = vec4(0.0);\n    vec4 noise_disp_map_2 = vec4(0.0);\n    vec4 caustics_disp_map_1 = vec4(0.0);\n    vec4 caustics_disp_map_2 = vec4(0.0);\n    vec4 background = vec4(0.0);\n\n    #ifdef PIXELATE_UV\n        uv = pixelate_uv(uv);\n    #endif\n\n    #ifdef RIPPLE_EFFECT\n        uv += compute_ripple_offset(uv);\n    #endif\n\n    #ifdef SHOW_NOISE_DISP_MAP_1\n        noise_disp_map_1 = sample_disp_map(\n            iChannel0, uv,\n            NOISE_DISP_MAP_1_SCROLL_VELOCITY,\n            NOISE_DISP_MAP_1_INITIAL_OFFSET,\n            NOISE_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_NOISE_DISP_MAP_2\n        noise_disp_map_2 = sample_disp_map(\n            iChannel0, uv,\n            NOISE_DISP_MAP_2_SCROLL_VELOCITY,\n            NOISE_DISP_MAP_2_INITIAL_OFFSET,\n            NOISE_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_CAUSTICS_DISP_MAP_1\n        caustics_disp_map_1 = sample_disp_map(\n            iChannel2, uv,\n            CAUSTICS_DISP_MAP_1_SCROLL_VELOCITY,\n            ZERO_POSITIONAL_OFFSET,\n            CAUSTICS_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_CAUSTICS_DISP_MAP_2\n        caustics_disp_map_2 = sample_disp_map(\n            iChannel2, uv,\n            CAUSTICS_DISP_MAP_2_SCROLL_VELOCITY,\n            ZERO_POSITIONAL_OFFSET,\n            CAUSTICS_DISP_MAP_DIMMING_FACTOR\n        );\n    #endif\n\n    #ifdef SHOW_BACKGROUND\n        //basic dicplacement map integration\n        background = sample_background_with_disp_map(iChannel1, uv, noise_disp_map_1, BACKGROUND_DISP_WARP_FACTOR);\n    #endif\n\n    float alpha = compute_effective_opacity(\n        noise_disp_map_1,\n        noise_disp_map_2,\n        caustics_disp_map_1,\n        caustics_disp_map_2\n    );\n\n    frag_color = (noise_disp_map_1 + noise_disp_map_2) * alpha + background;\n    //COLOR = (noise_disp_map_1 + noise_disp_map_2) * alpha + background;\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "t3lGRj",
    "date": "0",
    "viewed": 0,
    "name": "godot sample clamping test",
    "description": "tsting clamping issue with godot ",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "godot"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//uniform sampler2D iChannel0;\n//uniform vec2 iResolution;\n\n//void fragment() {\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n    frag_color = texture(iChannel0, uv) / 10.0;\n    //COLOR = texture(iChannel0, uv) / 10.0;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n\n//void fragment() {\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    frag_color = vec4(10.0, 10.0, 10.0, 1.0);\n    //COLOR = vec4(10.0, 10.0, 10.0, 1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXf3Rl",
    "date": "0",
    "viewed": 0,
    "name": "godot fragcoord inversion",
    "description": "frag",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "godot"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n\n//uniform vec2 iResolution;\n//uniform vec3 iMouse;      \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n//void fragment() {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;  \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float dist_from_mouse = distance(uv, mouseUV);\n\n    float is_pressed = step(0.5, iMouse.z);  // 1.0 if mouse pressed, 0.0 otherwise\n    float debugImpulse = smoothstep(0.2, 0.0, dist_from_mouse) * is_pressed;\n\n    // We’ll pack some easy-to-read values into RGBA:\n    //   R = uv.y          (the “vertical coordinate” in Godot’s system)\n    //   G = mouseUV.y     (the mouse’s vertical coordinate, 0..1)\n    //   B = debugImpulse  (shows a ring if the button is pressed)\n    //   A = 1\n    //COLOR = vec4(uv.y, mouseUV.y, debugImpulse, 1.0);\n    fragColor = vec4(uv.y, mouseUV.y, debugImpulse, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XXGzl",
    "date": "0",
    "viewed": 0,
    "name": "propagation debug",
    "description": "fff",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fff"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "shader_type canvas_item;\n\nuniform vec3 iMouse;\nuniform vec2 iResolution;\nuniform sampler2D iChannel0; \n\n//void mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvoid fragment() {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n\n    // dbg.r = uv.y  from Pass A\n    // dbg.g = mouseUV.y\n    // dbg.b = ring\n    vec4 dbg = texture(iChannel0, uv);\n\n    float ringVal = dbg.b;\n\n    float stepSize = 0.005;\n    float sumRing = texture(iChannel0, uv + vec2(+stepSize, 0.0)).b +\n                    texture(iChannel0, uv + vec2(-stepSize, 0.0)).b +\n                    texture(iChannel0, uv + vec2(0.0, +stepSize)).b +\n                    texture(iChannel0, uv + vec2(0.0, -stepSize)).b +\n                    ringVal; \n    float avgRing = sumRing / 5.0;\n\n    // We also fade it slightly, so it doesn't grow forever\n    avgRing *= 0.98;\n\n    // For more dramatic effect, let's color-shift by the debug pass's R channel (the pixel's Y).\n    // That means if there's an inverted coordinate, you'll see color differences top vs bottom.\n    float yCoord = dbg.r;\n    vec3 color = vec3(avgRing * yCoord, avgRing, avgRing * (1.0 - yCoord));\n\n    //COLOR = vec4(color, 1.0);\n    fragColor =  vec4(color, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "shader_type canvas_item;\n\nuniform vec2 iResolution; \nuniform vec3 iMouse;      \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n//void fragment() {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;  \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float dist_from_mouse = distance(uv, mouseUV);\n\n    float is_pressed = step(0.5, iMouse.z);  // 1.0 if mouse pressed, 0.0 otherwise\n    float debugImpulse = smoothstep(0.2, 0.0, dist_from_mouse) * is_pressed;\n\n    // We’ll pack some easy-to-read values into RGBA:\n    //   R = uv.y          (the “vertical coordinate” in Godot’s system)\n    //   G = mouseUV.y     (the mouse’s vertical coordinate, 0..1)\n    //   B = debugImpulse  (shows a ring if the button is pressed)\n    //   A = 1\n    //COLOR = vec4(uv.y, mouseUV.y, debugImpulse, 1.0);\n    fragColor = vec4(uv.y, mouseUV.y, debugImpulse, 1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wX23Rm",
    "date": "1747198710",
    "viewed": 16,
    "name": "simplest waveform visual",
    "description": "waveform",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "waveform"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//render_mode blend_disabled;\n\n//uniform vec2 iResolution;\n//uniform sampler2D iChannel0;\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n#define WAVEFORM_ROW 1.0\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord){\n//void fragment() {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n    vec2 waveform_row_coords = vec2(uv.x, WAVEFORM_ROW);\n    float waveform_amplitude_value = texture(iChannel0, waveform_row_coords).r; //R-channel is the only one i write to in the texture builder\n\n    vec4 color = BLACK;\n    if(uv.y < waveform_amplitude_value) {\n        color = WHITE; // white for all values under the waveform y-value\n    }\n\n    frag_color = color;\n    //COLOR = color;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "t3jGzm",
    "date": "1743991184",
    "viewed": 35,
    "name": "basic fft visualizer",
    "description": "fft",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fft"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//render_mode blend_disabled;\n\n//uniform vec2 iResolution;\n//uniform sampler2D iChannel0;\n#define total_fft_buffer_size_in_bins 512.0\n\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n#define FFT_ROW 0.0\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    //vec2 frag_coord = FRAGCOORD.xy;\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    float cell_width = iResolution.x / total_fft_buffer_size_in_bins;\n    float bin_index = floor(frag_coord.x / cell_width);\n    float local_x = mod(frag_coord.x, cell_width);\n    float bar_width = cell_width - 1.0;\n    vec4 color = BLACK;\n    if (local_x <= bar_width) {\n        float sample_x = (bin_index + 0.5) / total_fft_buffer_size_in_bins;\n        vec2 sample_coord = vec2(sample_x, FFT_ROW);\n        float amplitude = texture(iChannel0, sample_coord).r;\n        if (uv.y < amplitude) {\n            color = WHITE;\n        }\n    }\n    frag_color = color;\n    //COLOR = color;\n}\n\n\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXjGWz",
    "date": "1743995745",
    "viewed": 27,
    "name": "godot audio envelope",
    "description": "envelpo",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "godot"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//render_mode blend_disabled;\n\n//#include \"res://Resources/Shaders/Audio/audio_plotting.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform sampler2D iChannel0;\n//#iChannel0 \"file://shaders/buffers/audio_feedback_envelope.glsl\" \n\n#define LINE_RENDER_MARGIN 0.23        // amount of thickness (in fragment size/single pixel) that surrounds both sides of the wave signal lines\n#define MAX_DISTANCE 1e6               // some stupid number to just initialize the min distance to closest wave signal logic\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n\nvec2 project_isometric(vec3 envelope_data) {\n    vec2 raw_proj    = project(envelope_data);\n    vec2 grid_center = compute_envelope_grid_center();\n    vec2 screen_center = iResolution.xy * HALF_SCREEN;\n    return raw_proj + (screen_center - grid_center);\n}\n\nfloat sample_wave_signal_from_envelope_buffer(float bin_index, float wave_signal_vertical_index){\n    float sample_offset = 0.5; // TODO: this eliminates the sampling issues on the edges of the line\n    // horizontal sampling normalization\n    float normalized_bin_index = (bin_index + sample_offset) / NUM_BINS;\n    // normalize and flip the order of the wave signals to have the \"closest signal\"/bottom signal be the first signal in the history \n    float normalized_wave_signal_index = TOTAL_CANVAS_HEIGHT - ((wave_signal_vertical_index + sample_offset) / NUM_HISTORICAL_WAVE_SIGNAL_LINES);\n    // essentially this is the abstract sampling of the envelope buffer to get:\n    // horizontal data = current location in the audio bin (the amplitudes that make up the individual lines)\n    // vertical data = current wave signal that will be updated/drawn to the screen (index in the envelopes discrete history)\n    vec2 uv = vec2(normalized_bin_index, normalized_wave_signal_index);\n    return texture(iChannel0, uv).r;\n}\n\nfloat min_distance_to_nearby_isometric_wave_signals(vec2 frag_coord) {\n    float nearest_distance_to_nearby_wave_signals = MAX_DISTANCE;\n    for (int wave_signal_index = 0; wave_signal_index < int(NUM_HISTORICAL_WAVE_SIGNAL_LINES); wave_signal_index++) {\n        float wave_signal_index_f = float(wave_signal_index);\n\n        for (int bin_index = 0; bin_index < int(NUM_BINS) - 1; bin_index++) {\n            float bin_index_f        = float(bin_index);\n            float next_bin_index_f   = float(bin_index + 1);\n\n            float current_envelope_val  = sample_wave_signal_from_envelope_buffer(bin_index_f, wave_signal_index_f);\n            float neighbor_envelope_val = sample_wave_signal_from_envelope_buffer(next_bin_index_f, wave_signal_index_f);\n            \n            vec3 current_envelope_data  = vec3(bin_index_f, current_envelope_val,  wave_signal_index_f);\n            vec3 neighbor_envelope_data = vec3(next_bin_index_f, neighbor_envelope_val, wave_signal_index_f);\n            \n            vec2 projected_current  = project_isometric(current_envelope_data);\n            vec2 projected_neighbor = project_isometric(neighbor_envelope_data);\n            \n            vec2 line_segment_vector  = projected_neighbor - projected_current;\n            float segment_length_squared = dot(line_segment_vector, line_segment_vector);\n            \n            float projection_factor = dot(frag_coord - projected_current, line_segment_vector) / segment_length_squared;\n            float line_segment_param = clamp(projection_factor, 0.0, 1.0);\n            \n            vec2 nearest_point_on_line = projected_current + line_segment_param * line_segment_vector;\n            float distance_to_nearest_point = distance(frag_coord, nearest_point_on_line);\n            \n            nearest_distance_to_nearby_wave_signals = min(nearest_distance_to_nearby_wave_signals, distance_to_nearest_point);\n        }\n    }\n    return nearest_distance_to_nearby_wave_signals;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    float dist = min_distance_to_nearby_isometric_wave_signals(frag_coord);\n    //float dist = min_distance_to_nearby_isometric_wave_signals(FRAGCOORD.xy);\n\n    // Use fwidth for adaptive anti-aliasing????\n    float aa = fwidth(dist);\n    // LINE_RENDER_MARGIN * 2.0 is the threshold, but smoothstep will blend within aa units????\n    float edge = smoothstep(LINE_RENDER_MARGIN * 4.0, LINE_RENDER_MARGIN * 4.0 - aa, dist);\n    frag_color = mix(BLACK, WHITE, edge);\n    //COLOR = mix(BLACK, WHITE, edge);\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//render_mode blend_disabled;\n\n//#include \"res://Resources/Shaders/Audio/audio_plotting.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform float iTime;\n//uniform sampler2D iChannel0: hint_screen_texture;\n//uniform sampler2D iChannel1; //audio texture\n//#iChannel1 \"file://assets/audio/Hellion_v2.ogg\"\n\n/*\n * Envelope Shader\n *  - Envelope: controlled amplitude profile of the audio (including histories)\n *  - Audio Bin: a group of waveform samples (segements of amplitudes from the waveform data)\n *  - Waveform Data: amplitude data stored in the audio texture's y= 1.0 channel, i.e. values distributed all across the x=0~511 indicies.\n */\n\n// EFFECTIVE DOMAIN: [128.0, 512.0] \n#define TOTAL_WAVEFORM_SAMPLES 512.0 // number of x-axis values read from the audio texture (at y=1.0) (max is actually 512 according to shadertoy)\n// EFFECTIVE DOMAIN: {1.0}\n#define WAVEFORM_DATA_COORD_Y 1.0 // fixed Y coordinate for sampling waveform data from audio texture\n// EFFECTIVE DOMAIN: [0.1, 1.0]\n//#define ENVELOPE_SMOOTHING_FACTOR 0.05 // percent of how much of the newly ACCUMULATED amplitudes get applied to the \"envelope\" (line shapes) per history update\n// Define a macro for propagation speed (adjust the value as needed)\n#define PROPAGATION_SPEED 0.00015\n\n#define AUDIO_BIN_SAMPLE_COUNT (TOTAL_WAVEFORM_SAMPLES / NUM_BINS) // how many waveform x-values are grouped together to form each bin’s envelope value \n\nvec4 sample_previous_wave_signal(vec2 uv, float wave_signal_vertical_index) {\n    // Calculate an offset based on iTime and the defined propagation speed.\n    float offset = PROPAGATION_SPEED * iTime;\n    vec2 previous_wave_signal_index_offset = vec2(0.0, wave_signal_vertical_index * offset);\n    vec2 target_previous_wave_signal = uv + previous_wave_signal_index_offset;\n    return texture(iChannel0, target_previous_wave_signal);\n}\n\n//TODO: you messed up now you have to figure out all this crazy shit later good job idiot\n//TODO: refactor this to make sure that you have true control over the smoothness of the waves, and how fast they propagate in the history\n// Suggested smoothing factors (tweak these until you get the desired effect)\n// SLOW_SMOOTHING controls how quickly the overall envelope adapts (small values → very slow changes)\n// FAST_SMOOTHING controls the fast transient contribution (higher values react quickly)\n#define SLOW_SMOOTHING 0.05  \n#define FAST_SMOOTHING 0.25\n// A threshold to decide when to let fast transients show through\n#define TRANSIENT_THRESHOLD 0.1\n\nfloat compute_envelope_for_audio_bin(float bin_index) {\n    float total_amplitude = 0.0;\n    for (int i = 0; i < int(AUDIO_BIN_SAMPLE_COUNT); i++) {\n        float i_f = float(i);\n        float sample_coord_x = (bin_index * AUDIO_BIN_SAMPLE_COUNT + i_f) / TOTAL_WAVEFORM_SAMPLES;\n        vec2 sample_coords = vec2(sample_coord_x, WAVEFORM_DATA_COORD_Y);\n        float sample_amplitude = texture(iChannel1, sample_coords).r;\n        total_amplitude += abs(sample_amplitude);\n    }\n    return total_amplitude / AUDIO_BIN_SAMPLE_COUNT;\n}\n\nvec4 update_envelope_history(vec2 uv) {\n    float bin_index = floor(uv.x * NUM_BINS);\n    float newEnv = compute_envelope_for_audio_bin(bin_index);\n    vec4 history = texture(iChannel0, uv);\n\n    // Compute the overall (slow) and fast transient parts.\n    float overall = mix(history.r, newEnv, SLOW_SMOOTHING);\n    float fast    = mix(history.g, newEnv, FAST_SMOOTHING);\n    float delta   = fast - overall;\n    float transient = (abs(delta) > TRANSIENT_THRESHOLD) ? delta : 0.0;\n    float finalEnvelope = overall + transient;\n\n    // Shift the history:\n    // New envelope becomes red, previous red -> green, green -> blue, blue -> alpha.\n    return vec4(finalEnvelope, history.r, history.g, history.b);\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    vec2 uv = frag_coord / iResolution.xy;\n    //vec2 uv = FRAGCOORD.xy / iResolution.xy;\n\n    // Each historical row index (of the 5 wave signal lines) occupies an equal portion of the vertical display\n    // this is just which line is targetted in the 1~5 lines\n    float wave_signal_vertical_index = TOTAL_CANVAS_HEIGHT / NUM_HISTORICAL_WAVE_SIGNAL_LINES;\n    // The bottom row (highest y-values) is where new envelope values are drawn\n    // If the current fragment is not in the bottom row, draw the history through the line\n    if (uv.y < TOTAL_CANVAS_HEIGHT - wave_signal_vertical_index) {\n        frag_color = sample_previous_wave_signal(uv, wave_signal_vertical_index);\n        //COLOR = sample_previous_wave_signal(uv, wave_signal_vertical_index);\n    } else {\n        // otherwise update the histories\n        frag_color = update_envelope_history(uv);\n        //COLOR = update_envelope_history(uv);\n    }\n}\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define NUM_BINS 64.0 // how to subdivide the 512 samples from the waveform data (effectively length of the wave signals data)\n#define NUM_HISTORICAL_WAVE_SIGNAL_LINES 5.0 // how many wave signals to propagate a history for\n#define TOTAL_CANVAS_HEIGHT 1.0  //used for flipping the order of the lines\n\n//TODO: properly refactor this whole utility code so that things actually make sense and are customizable\n#define AMPLITUDE_SCALE 120.0    // scaling\n#define ISOMETRIC_ZOOM 3.0       // more scalling\n#define ROW_SPACING 9.0          // again.. a scaling thing\n#define HALF_SCREEN 0.5          // Constant 0.5 for centering calculations.\n\nvec2 project(vec3 envelope_data) {\n    float bin_index = envelope_data.x;\n    float envelope_value = envelope_data.y;\n    float history_row = envelope_data.z;\n\n    float effective_row = history_row * ROW_SPACING;\n\n    float proj_x = bin_index - effective_row;\n    float proj_y = (bin_index + effective_row) * HALF_SCREEN - envelope_value * AMPLITUDE_SCALE;\n\n    return vec2(proj_x, proj_y) * ISOMETRIC_ZOOM;\n}\n\nvec2 compute_envelope_grid_center() {\n    float num_bins_minus_one = NUM_BINS - 1.0;\n    float num_history_rows_minus_one = NUM_HISTORICAL_WAVE_SIGNAL_LINES - 1.0;\n\n    vec2 proj_bottom_left  = project(vec3(0.0, 0.0, 0.0));\n    vec2 proj_bottom_right = project(vec3(num_bins_minus_one, 0.0, 0.0));\n    vec2 proj_top_left     = project(vec3(0.0, 1.0, num_history_rows_minus_one));\n    vec2 proj_top_right    = project(vec3(num_bins_minus_one, 1.0, num_history_rows_minus_one));\n\n    vec2 min_corner = min(min(proj_bottom_left, proj_bottom_right), min(proj_top_left, proj_top_right));\n    vec2 max_corner = max(max(proj_bottom_left, proj_bottom_right), max(proj_top_left, proj_top_right));\n\n    return (min_corner + max_corner) * HALF_SCREEN;\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXjGWw",
    "date": "1744294888",
    "viewed": 43,
    "name": "framerate agnosticism study",
    "description": "sound envelope refactoring",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define LINE_RENDER_WIDTH 0.75\n#define LINE_RENDER_MARGIN (LINE_RENDER_WIDTH * 2.0) // amount of thickness (in fragment size/single pixel) that surrounds both sides of the wave signal lines\n#define MAX_DISTANCE 1e6 // some stupid number to just initialize the min distance to closest wave signal logic\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n\n\nfloat get_envelope_from_buffer(int history_row, int segment_index) {\n    float texture_v = 1.0 - (float(history_row) + 0.5) / float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS);\n    float texture_u = (float(segment_index) + 0.5) / float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS);\n    return texture(iChannel0, vec2(texture_u, texture_v)).r;\n}\n\nvec2 project_centered_envelope(vec3 envelope_coordinate) {\n    vec2 raw_projected_coordinate = project_envelope(envelope_coordinate);\n    vec2 grid_center = compute_envelope_grid_center();\n    vec2 screen_center = iResolution.xy * 0.5;\n    return raw_projected_coordinate + (screen_center - grid_center);\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    float closest_distance = MAX_DISTANCE;\n    for (int history_row = 0; history_row < NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS; history_row++) {\n        for (int segment_index = 0; segment_index < DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1; segment_index++) {\n            float envelope_left = get_envelope_from_buffer(history_row, segment_index);\n            float envelope_right = get_envelope_from_buffer(history_row, segment_index + 1);\n\n            vec3 envelope_coordinate_left = vec3(float(segment_index), envelope_left, float(history_row));\n            vec3 envelope_coordinate_right = vec3(float(segment_index + 1), envelope_right, float(history_row));\n\n            vec2 screen_position_left = project_centered_envelope(envelope_coordinate_left);\n            vec2 screen_position_right = project_centered_envelope(envelope_coordinate_right);\n\n            float distance_to_wave_line = distance_to_line(frag_coord.xy, screen_position_left, screen_position_right);\n            closest_distance = min(closest_distance, distance_to_wave_line);\n        }\n    }\n\n    float intensity = 1.0 - smoothstep(LINE_RENDER_WIDTH, LINE_RENDER_MARGIN, closest_distance);\n    frag_color = vec4(vec3(intensity), 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define WAVEFORM_SAMPLE_COUNT 512 //TODO: derive this from the actual ShaderToyAudioTexture constants??? it doesnt even need to 512?\n#define WAVEFORM_SAMPLE_COUNT_F float(WAVEFORM_SAMPLE_COUNT)\n#define AUDIO_TEXTURE_WAVEFORM_ROW 1.0 //TODO: derive this from the actual ShaderToyAudioTexture constants\n\n#define UNUSED_FEEDBACK_CHANNEL 0.0\n#define WAVEFORM_SEGMENT_CENTERING_OFFSET 0.5\n\n#define WAVEFORM_SAMPLES_PER_SEGMENT (WAVEFORM_SAMPLE_COUNT / DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS)\n#define WAVEFORM_SAMPLES_PER_SEGMENT_F (WAVEFORM_SAMPLE_COUNT_F / DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F)\n\n#define TARGET_BLEND_INTENSITY_BETWEEN_ENVELOPE_INJECTION_SNAPSHOTS 0.6\n#define INJECTION_INTERVAL 0.1 //e.g. every 0.1 second: open the injection window\n\n#define INJECTION_WINDOW 0.8 // e.g. when injection occurs allow 80% of 0.1 second = 0.08 seconds of buffered waveforms to enter the envelope???\n\n#define PROPAGATION_RATE_FRAME 0.5 // coupled to frame rate?????  e.g. for 30fps, every 15 frames (50% of 30fps) = 15/30 fps -> propagation occurs every 0.5 seconds, i.e. ~2 times per second. propagate the injected waveforms upwards through the envelope snapshots\n\nfloat compute_normalized_sample_coordinate_for_downscaled_segment_in_1D(float segment_index, float sample_index) {\n    float sample_coordinate_on_1D_x_axis = segment_index * WAVEFORM_SAMPLES_PER_SEGMENT_F + sample_index + WAVEFORM_SEGMENT_CENTERING_OFFSET;\n    return sample_coordinate_on_1D_x_axis / WAVEFORM_SAMPLE_COUNT_F; \n}\n\nfloat sample_audio_texture_waveform_data(int segment_index) {\n    float accumulated_amplitude = 0.0;\n    for (int sample_index = 0; sample_index < WAVEFORM_SAMPLES_PER_SEGMENT; sample_index++) {\n        float segment_index_in_continious_space = float(segment_index);\n        float sample_index_in_continious_space = float(sample_index);\n        float normalized_sample_coordinate_for_downscaled_segment_in_1D = compute_normalized_sample_coordinate_for_downscaled_segment_in_1D(segment_index_in_continious_space, sample_index_in_continious_space);\n        vec2 sample_coordinates = vec2(normalized_sample_coordinate_for_downscaled_segment_in_1D, AUDIO_TEXTURE_WAVEFORM_ROW);\n        float amplitude_value_at_sample_coordinates = texture(iChannel1, sample_coordinates).r;\n        accumulated_amplitude += abs(amplitude_value_at_sample_coordinates);\n    }\n    return accumulated_amplitude / WAVEFORM_SAMPLES_PER_SEGMENT_F;\n}\n\nfloat propagate_envelope_injection_snapshot_upwards(vec2 uv, float y_shift) {\n    vec4 envelope_fragment = texture(iChannel0, uv + vec2(0.0, y_shift));\n    return envelope_fragment.r;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    float uv_height_per_envelope_snapshot = 1.0 / float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS);\n    if (uv.y < 1.0 - uv_height_per_envelope_snapshot) {\n        float envelope_fragment = propagate_envelope_injection_snapshot_upwards(uv, PROPAGATION_RATE_FRAME * uv_height_per_envelope_snapshot);\n        frag_color = vec4(envelope_fragment, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n    } else {\n        float current_envelope = texture(iChannel0, uv).r;\n        float normalized_time_since_last_injection = fract(iTime / INJECTION_INTERVAL);\n        if (normalized_time_since_last_injection < INJECTION_WINDOW) {\n            int segment_index_in_discrete_space = int(floor(uv.x * DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F));\n            float next_envelope = sample_audio_texture_waveform_data(segment_index_in_discrete_space);\n            float injection_blend_intensity_coefficient = 1.0;\n            float t = normalized_time_since_last_injection / INJECTION_WINDOW;\n\n            float smooth_injection = 0.5 * (1.0 - cos(6.28318 * t)); //TODO: I dont like this, but it kind of helps with smoothing?\n            float effective_injection_blend = smooth_injection * injection_blend_intensity_coefficient * TARGET_BLEND_INTENSITY_BETWEEN_ENVELOPE_INJECTION_SNAPSHOTS;\n            float blended_envelope = mix(current_envelope, next_envelope, effective_injection_blend);\n            frag_color = vec4(blended_envelope, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n        } else {\n            frag_color = vec4(current_envelope, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n        }\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS 64\n#define DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS)\n#define NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS 5\n#define AMPLITUDE_SCALE 200.0\n#define ISOMETRIC_ZOOM 6.0\n#define ROW_SPACING 8.0\n\nvec2 project_envelope(vec3 envelope_coordinate) {\n    float segment_index   = envelope_coordinate.x;\n    float envelope_value  = envelope_coordinate.y;\n    float history_row     = envelope_coordinate.z;\n    float effective_row   = history_row * ROW_SPACING;\n    float projected_x = segment_index - effective_row;\n    float projected_y = (segment_index + effective_row) * 0.5 - envelope_value * AMPLITUDE_SCALE;\n    return vec2(projected_x, projected_y) * ISOMETRIC_ZOOM;\n}\n\nvec2 compute_envelope_grid_center() {\n    vec2 projected_bottom_left  = project_envelope(vec3(0.0, 0.0, 0.0));\n    vec2 projected_bottom_right = project_envelope(vec3(float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1), 0.0, 0.0));\n    vec2 projected_top_left     = project_envelope(vec3(0.0, 1.0, float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS - 1)));\n    vec2 projected_top_right    = project_envelope(vec3(float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1), 1.0, float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS - 1)));\n\n    vec2 minimum_corner = min(min(projected_bottom_left, projected_bottom_right),\n                              min(projected_top_left, projected_top_right));\n    vec2 maximum_corner = max(max(projected_bottom_left, projected_bottom_right),\n                              max(projected_top_left, projected_top_right));\n    return (minimum_corner + maximum_corner) * 0.5;\n}\n\nfloat distance_to_line(vec2 pixel_coordinate, vec2 line_start, vec2 line_end) {\n    vec2 line_vector = line_end - line_start;\n    float line_length_squared = dot(line_vector, line_vector);\n    float projection_factor = dot(pixel_coordinate - line_start, line_vector) / line_length_squared;\n    float clamped_projection_factor = clamp(projection_factor, 0.0, 1.0);\n    vec2 closest_point = line_start + clamped_projection_factor * line_vector;\n    return distance(pixel_coordinate, closest_point);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W323Rc",
    "date": "1744360502",
    "viewed": 33,
    "name": "sound envelope with two buffers",
    "description": "sound",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define LINE_RENDER_WIDTH 0.75\n#define LINE_RENDER_MARGIN (LINE_RENDER_WIDTH * 2.0) // amount of thickness (in fragment size/single pixel) that surrounds both sides of the wave signal lines\n#define MAX_DISTANCE 1e6 // some stupid number to just initialize the min distance to closest wave signal logic\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n#define BUFFER_A_1D_ROW 0.0\n\n#define FRAMES_PER_PROPAGATION 5.\n\nfloat get_envelope_from_buffer(int history_row, int segment_index) {\n    float texture_u = (float(segment_index) + 0.5) / float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS);\n    return texture(iChannel0, vec2(texture_u, BUFFER_A_1D_ROW)).r;\n}\n\nvec2 project_centered_envelope(vec3 envelope_coordinate) {\n    vec2 raw_projected_coordinate = project_envelope(envelope_coordinate);\n    vec2 grid_center = compute_envelope_grid_center();\n    vec2 screen_center = iResolution.xy * 0.5;\n    return raw_projected_coordinate + (screen_center - grid_center);\n}\n\nvec4 propagate_envelope_injection_snapshot_isometrically(vec2 uv, vec2 uv_shift) {\n    vec4 envelope_fragment = texture(iChannel1, uv + uv_shift);\n    return envelope_fragment;\n}\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n\n    vec2 uv_shift = compute_isometric_uv_shift(iResolution.xy);\n\n    float should_propagate = step(0.5, 1.0 - step(0.001, mod(float(iFrame), float(FRAMES_PER_PROPAGATION))));\n\n    vec4 propagated_fragment = texture(iChannel1, uv + uv_shift * should_propagate);\n    float current_amplitude = propagated_fragment.r;\n    float current_snapshot_index = propagated_fragment.a + should_propagate;\n\n    if (current_snapshot_index >= float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS)) {\n        current_amplitude = 0.0;\n        current_snapshot_index = 0.0;\n    }\n\n    float new_intensity = 0.0;\n\n    if (should_propagate > 0.5) {\n        float closest_distance = MAX_DISTANCE;\n        for (int segment_index = 0; segment_index < DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1; segment_index++) {\n            float envelope_left = get_envelope_from_buffer(0, segment_index);\n            float envelope_right = get_envelope_from_buffer(0, segment_index + 1);\n\n            vec3 envelope_coordinate_left = vec3(float(segment_index), envelope_left, 0.);\n            vec3 envelope_coordinate_right = vec3(float(segment_index + 1), envelope_right, 0.);\n\n            vec2 screen_position_left = project_centered_envelope(envelope_coordinate_left);\n            vec2 screen_position_right = project_centered_envelope(envelope_coordinate_right);\n\n            float distance_to_wave_line = distance_to_line(frag_coord.xy, screen_position_left, screen_position_right);\n            closest_distance = min(closest_distance, distance_to_wave_line); \n        }\n        new_intensity = 1.0 - smoothstep(LINE_RENDER_WIDTH, LINE_RENDER_MARGIN, closest_distance);\n    }\n\n    if (new_intensity > 0.01) {\n        current_amplitude = new_intensity;\n        current_snapshot_index = 0.0;\n    }\n\n    frag_color = vec4(current_amplitude, current_amplitude, current_amplitude, current_snapshot_index);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define WAVEFORM_SAMPLE_COUNT 512 //TODO: derive this from the actual ShaderToyAudioTexture constants??? it doesnt even need to 512?\n#define WAVEFORM_SAMPLE_COUNT_F float(WAVEFORM_SAMPLE_COUNT)\n#define AUDIO_TEXTURE_WAVEFORM_ROW 1.0 //TODO: derive this from the actual ShaderToyAudioTexture constants\n\n#define WAVEFORM_SEGMENT_CENTERING_OFFSET 0.5\n\n#define WAVEFORM_SAMPLES_PER_SEGMENT (WAVEFORM_SAMPLE_COUNT / DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS)\n#define WAVEFORM_SAMPLES_PER_SEGMENT_F (WAVEFORM_SAMPLE_COUNT_F / DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F)\n\n#define TARGET_BLEND_INTENSITY_BETWEEN_ENVELOPE_INJECTION_SNAPSHOTS 0.5\n#define INJECTION_INTERVAL 1.0 //e.g. every 0.1 second: open the injection window\n\n#define INJECTION_WINDOW 0.8 // e.g. when injection occurs allow 80% of 0.1 second = 0.08 seconds of buffered waveforms to enter the envelope???\n\n\nfloat compute_normalized_sample_coordinate_for_downscaled_segment_in_1D(float segment_index, float sample_index) {\n    float sample_coordinate_on_1D_x_axis = segment_index * WAVEFORM_SAMPLES_PER_SEGMENT_F + sample_index + WAVEFORM_SEGMENT_CENTERING_OFFSET;\n    return sample_coordinate_on_1D_x_axis / WAVEFORM_SAMPLE_COUNT_F; \n}\n\nfloat sample_audio_texture_waveform_data(int segment_index) {\n    float accumulated_amplitude = 0.0;\n    for (int sample_index = 0; sample_index < WAVEFORM_SAMPLES_PER_SEGMENT; sample_index++) {\n        float segment_index_in_continious_space = float(segment_index);\n        float sample_index_in_continious_space = float(sample_index);\n        float normalized_sample_coordinate_for_downscaled_segment_in_1D = compute_normalized_sample_coordinate_for_downscaled_segment_in_1D(segment_index_in_continious_space, sample_index_in_continious_space);\n        vec2 sample_coordinates = vec2(normalized_sample_coordinate_for_downscaled_segment_in_1D, AUDIO_TEXTURE_WAVEFORM_ROW);\n        float amplitude_value_at_sample_coordinates = texture(iChannel1, sample_coordinates).r;\n        accumulated_amplitude += abs(amplitude_value_at_sample_coordinates);\n    }\n    return accumulated_amplitude / WAVEFORM_SAMPLES_PER_SEGMENT_F;\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    float u = frag_coord.x / iResolution.x;\n    // Force vertical coordinate to 0.0 (for instance, the first row). BUFFER A IS NOW 1D!!\n    float v = 0.0;\n    vec2 uv = vec2(u, v);\n    float current_envelope = texture(iChannel0, uv).r;\n    float normalized_time_since_last_injection = fract(iTime / INJECTION_INTERVAL);\n    if (normalized_time_since_last_injection < INJECTION_WINDOW) {\n        int segment_index_in_discrete_space = int(floor(uv.x * DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F));\n        float next_envelope = sample_audio_texture_waveform_data(segment_index_in_discrete_space);\n        float injection_blend_intensity_coefficient = 1.0;\n        float t = normalized_time_since_last_injection / INJECTION_WINDOW;\n\n        float smooth_injection = 0.5 * (1.0 - cos(6.28318 * t)); //TODO: I dont like this, but it kind of helps with smoothing?\n        float effective_injection_blend = smooth_injection * injection_blend_intensity_coefficient * TARGET_BLEND_INTENSITY_BETWEEN_ENVELOPE_INJECTION_SNAPSHOTS;\n        float blended_envelope = mix(current_envelope, next_envelope, effective_injection_blend);\n        frag_color = vec4(blended_envelope, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n    } else {\n        frag_color = vec4(current_envelope, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS 64\n#define DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F 64.\n#define NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS 5\n#define AMPLITUDE_SCALE 100.0\n#define ISOMETRIC_ZOOM 6.0\n#define ROW_SPACING 8.0\n#define UNUSED_FEEDBACK_CHANNEL 0.0\n\n\nvec2 project_envelope(vec3 envelope_coordinate) {\n    float segment_index   = envelope_coordinate.x;\n    float envelope_value  = envelope_coordinate.y;\n    float history_row     = envelope_coordinate.z;\n    float effective_row   = history_row * ROW_SPACING;\n    float projected_x = segment_index - effective_row;\n    float projected_y = (segment_index + effective_row) * 0.5 - envelope_value * AMPLITUDE_SCALE;\n    return vec2(projected_x, projected_y) * ISOMETRIC_ZOOM;\n}\n\nvec2 compute_envelope_grid_center() {\n    vec2 projected_bottom_left  = project_envelope(vec3(0.0, 0.0, 0.0));\n    vec2 projected_bottom_right = project_envelope(vec3(float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1), 0.0, 0.0));\n    vec2 projected_top_left     = project_envelope(vec3(0.0, 1.0, 0.0));\n    vec2 projected_top_right    = project_envelope(vec3(float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1), 1.0, 0.0));\n\n    vec2 minimum_corner = min(min(projected_bottom_left, projected_bottom_right),\n                              min(projected_top_left, projected_top_right));\n    vec2 maximum_corner = max(max(projected_bottom_left, projected_bottom_right),\n                              max(projected_top_left, projected_top_right));\n    return (minimum_corner + maximum_corner) * 0.5;\n}\n\nvec2 compute_isometric_uv_shift(vec2 resolution_uniform) {\n    vec2 proj0 = project_envelope(vec3(0.0, 0.0, 1.0));\n    vec2 proj1 = project_envelope(vec3(0.0, 0.0, 0.0));\n    vec2 projected_diff = proj1 - proj0;  \n    return projected_diff / resolution_uniform;\n}\n\n\nfloat distance_to_line(vec2 pixel_coordinate, vec2 line_start, vec2 line_end) {\n    vec2 line_vector = line_end - line_start;\n    float line_length_squared = dot(line_vector, line_vector);\n    float projection_factor = dot(pixel_coordinate - line_start, line_vector) / line_length_squared;\n    float clamped_projection_factor = clamp(projection_factor, 0.0, 1.0);\n    vec2 closest_point = line_start + clamped_projection_factor * line_vector;\n    return distance(pixel_coordinate, closest_point);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXsSRn",
    "date": "1744952600",
    "viewed": 46,
    "name": "jt's icesheet verbose study ",
    "description": "new fork of jt's https://www.shadertoy.com/view/W3S3Dt i am trying to learn noise functions for the first time now...",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "ice"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//This shader is a fork and study of user www.shadertoy.com/user/jt 's works found here:\n//https://www.shadertoy.com/view/WXSGDt, \n//https://www.shadertoy.com/view/WX23Dc, \n//https://www.shadertoy.com/view/t3l3R7\n\n//please take a look at them before looking at this\n//NOTES: APRIL 17th - study what is isotropic and anisotropic, everytime i see those words my brain short circuits\n\n#define NOISE_SCROLL_VELOCITY              vec2(0.0, 0.1)\n\n//how big the noise blobs are (bigger number smaller blobs)\n\n//\"#$&#$&\"#$&#\"$&\"#$&\"#$&\"#$&\"#$&\"#$&\"#$&\"#$&\"#$&BIGGEST FIND IS THE RELATIONSHIP BETWEEN THIS SCALAR FOR ZOOM ON THE NOISE TEXTURE\n// AND THE NEAR_LAYER_DIVISOR_OFFSET\n#define GLOBAL_COORD_SCALAR                 180.0 \n\n#define ENABLE_STRETCH_NOISE_TEXTURE\n    //range of 1.0 to 1.5 is consistent in the stretching of the y here idk why\n    #define STRETCH_SCALAR_X                1.0\n    //elongate the y-axis of the noise texture... THIS IS BEFORE ROTATION!!!\n    #define STRETCH_SCALAR_Y                2.0\n\n#define ENABLE_ROTATION\n    //To achieve the same effect as ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS:\n    #define ROTATION_ANGLE        -PI_4\n    //#define ROTATION_ANGLE        (-PI_4 * 0.5)\n    #define ROTATION_MATRIX       mat2(cos(ROTATION_ANGLE), -sin(ROTATION_ANGLE),\\\n                                       sin(ROTATION_ANGLE),  cos(ROTATION_ANGLE))\n\n//I HAVE NO IDEA HOW THIS CORRECTION SCALAR WORKS... \n//IT COMPLETELY BLASTS THE WHOLE NOISE TEXTURE SAMPLE COORDINATES!\n//AT CERTAIN VALUES IT SEEMS TO SERVE AS A REDUNDANT decomposition of the GLOBAL_COORD_SCALAR\n//theoretically k???? where \"full\" aspect correction is:\n//k = sqrt((pow(STRETCH_SCALAR_X, 2.0) + pow(STRETCH_SCALAR_Y, 2.0)) / 2.0) ??????\n#define ENABLE_PRE_ROTATION_STRETCH_CORRECTION\n    //To achieve the same effect as ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS:\n    #define UNIFORM_CORRECTION_SCALAR sqrt(2.0) \n    //#define UNIFORM_CORRECTION_SCALAR (sqrt((pow(STRETCH_SCALAR_X, 2.0) + pow(STRETCH_SCALAR_Y, 2.0)) / 2.0))\n    //#define UNIFORM_CORRECTION_SCALAR 1.0\n\n//#define ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS (correction with rotation...)    \n    #define UNIFORM_SCALE_ROTATION_COMPOSED mat2(1.0,  1.0,  \\\n                                                -1.0,  1.0)\n//controls the amount of boundary between solid (ice) and non-solids(gaps/crevaces)\n//domain is dangerous [-0.11, 0.46]??? (stuff that goes too low in the negatives will crash firefox\n//FRAME RATE DIPS when trying even -0.11, more than that you risk crashing\n// to make the whole shttps://www.shadertoy.com/img/themes/dark/play.pngheet fully WHITE its somewhere around like 0.45~0.46\n//good range is like -0.1 ~ 0.1 if you want at least some interesting crevace shapes\n//IAN -- idea: whoa what if we could modulate this within different quadrants of the texture for more control over boundary patterns through out??????!!!!\n#define PERLIN_SOLID_THRESHOLD             -0.03 //this has no effect on perspective\n\n#define USE_VORONOI\n    #define VORONOI_SOLID_THRESHOLD             0.34\n//TODO: just another parameter to tune things with at the end (translation of sampling location kind of??\n#define NOISE_COORD_OFFSET                 vec2(2.0, 0.0) \n\nfloat sampleNoise(vec2 coord, float localNoiseScale) {\n    float x_displacement = iTime * NOISE_SCROLL_VELOCITY.x;\n    float y_displacement = iTime * NOISE_SCROLL_VELOCITY.y;\n    vec2 displaced_coordinate = vec2(\n        coord.x + x_displacement,\n        coord.y + y_displacement\n    );\n    vec2 scaled_coordinate = displaced_coordinate * GLOBAL_COORD_SCALAR;\n    vec2 stretched_coordinate = vec2(\n        scaled_coordinate.x * STRETCH_SCALAR_X,\n        scaled_coordinate.y * STRETCH_SCALAR_Y\n    );\n\n    #ifdef ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS\n        vec2 uniform_scaled_rotated_coordinate = UNIFORM_SCALE_ROTATION_COMPOSED * stretched_coordinate;\n        vec2 local_noise_scaled_coordinate = uniform_scaled_rotated_coordinate * localNoiseScale;\n    #else\n        //decompose the scaling and rotating affine transforms for more \"fine\" control\n        //TODO: idk if to correct before or after rotating...\n        vec2 uniform_scaled_coordinate = UNIFORM_CORRECTION_SCALAR * stretched_coordinate; \n        // WAH! note to go back to highschool dummy! how could i forget matrix ops Order matters! R * S ≠ S * R.\n        // row_vector × matrix is a transpose! (NOT WHAT WE WANT!)\n        vec2 rotated_coordinate = ROTATION_MATRIX * uniform_scaled_coordinate; \n        vec2 local_noise_scaled_coordinate = rotated_coordinate * localNoiseScale;\n    #endif\n\n    vec2 final_noise_coordinate = local_noise_scaled_coordinate - NOISE_COORD_OFFSET;\n    #ifdef USE_VORONOI\n        float sampled_noise = voronoi_edge_fast(final_noise_coordinate);\n\n    #else\n        float sampled_noise = perlin_noise_iq(final_noise_coordinate);\n    #endif\n    return sampled_noise;\n}\n\n\nbool isSolidAtCoord(vec2 coord, float localNoiseScale) {\n    float noiseValue = sampleNoise(coord, localNoiseScale);\n    #ifdef USE_VORONOI\n        // Voronoi returns ~[0,1], so invert the test: large distances → inside a cell → solid\n        return (noiseValue > VORONOI_SOLID_THRESHOLD);\n    #else\n        // Perlin returns ~[-1,1], your existing threshold was around –0.03\n        return (noiseValue < PERLIN_SOLID_THRESHOLD);\n    #endif\n    \n}\n\n//TODO: PARRALAX is not clicking with me yet, it results in just an extra top \"solid layer\" to perhaps overwrite the distant stuff to look more like parralax.\n// the real projection and effect is happening in the depth layer iterative projections of the noise texture\n#define ENABLE_PARALLAX\n    //TODO: !%#$\"$%\"#$&\"#$%\"#$%\"#$B%\"#$I FOUND IT, this was the location of the projection coefficient\n    // BUT ITS INCREDIBLY TIED TO THE SCALING FOR ZOOM AND ALL THAT\n    #define NEAR_LAYER_DIVISOR_OFFSET          6.0\n\n    //Ian note - this is really just the zoom factor of how low res we sample the noise pattern\n    //applied ONLY WHEN PARALAX IS OFF???\n    #define NOISE_SCALE_NEAR                   0.025\n\n//#define ENABLE_MODE7 //this is the only macro that seems to control what i am percieving as \"PERSPECTIVE\"\n\n    //DISTANT_LAYER_VERTICAL_OFFSET + HORIZON_LINE == 1.0 must be true for alignment \n    #define HORIZON_LINE                       0.75\n    #define DISTANT_LAYER_VERTICAL_OFFSET      0.25\n    #define DISTANT_LAYER_DIVISOR_OFFSET       1.0\n    #define NOISE_SCALE_DISTANT                0.005\n\n//TODO: This is not perspective\n//its more just like a \"darkening factor\" on the icesheets vertical faces/sidewalls\n//it also has an effect on the water's height: when water is on and then turn on perspective, the water line gets higher\n//Perhaps its relationship with MODE7 is where it becomes important??\n#define ENABLE_PERSPECTIVE \n\n    // Used if perspective is enabled: final scale factor = (PERSPECTIVE_OFFSET - y) / PERSPECTIVE_DIVISOR\n    // This moves the apparent horizon as y changes.\n    #define PERSPECTIVE_OFFSET                 2.0\n    #define PERSPECTIVE_DIVISOR                3.0\n\n    // Default scale factor if perspective is disabled. (No extra vertical scaling.)\n    #define PERSPECTIVE_SCALE_NEUTRAL          1.0\n\n//#define ENABLE_LAYER_RANDOMIZATION //no idea how this works, ignore for now\n    #define LAYER_OFFSET_MULTIPLIER            123.456\n    #define LAYER_OFFSET_DEFAULT               0.0\n\n\n// !!!!!!!1this function actually INSTANTIATES the chosenNoiseScale that will be used anywhere \n//down the line in the code after this function is called!!!!!!!!!!!!!!!!!!!!!!!\nvec2 applyLayerPerspective(vec2 originalCoord, out float chosenNoiseScale) {\n    #ifdef ENABLE_MODE7\n        chosenNoiseScale = NOISE_SCALE_DISTANT;\n        originalCoord.y += DISTANT_LAYER_VERTICAL_OFFSET;\n        originalCoord = originalCoord / (DISTANT_LAYER_DIVISOR_OFFSET - originalCoord.y);\n    #else\n        chosenNoiseScale = NOISE_SCALE_NEAR;\n        originalCoord = originalCoord / (NEAR_LAYER_DIVISOR_OFFSET - originalCoord.y);\n    #endif\n    return originalCoord;\n}\n\nint countFluidLayers(vec2 normalizedCoord, float perspectiveFactor, float layerOffset){\n    int depthCount = 0;\n    \n    while(true) {\n        float depthAsFloat = float(depthCount) + layerOffset;\n        \n        vec2 testCoord = normalizedCoord + vec2(0.0, depthAsFloat / GLOBAL_COORD_SCALAR) * perspectiveFactor;\n        \n        float localNoiseScale;\n        vec2 finalCoord = applyLayerPerspective(testCoord, localNoiseScale);\n\n        if(isSolidAtCoord(finalCoord, localNoiseScale)) {\n            break;\n        }\n\n        if(normalizedCoord.y + (float(depthCount) / GLOBAL_COORD_SCALAR) >= iResolution.y) {\n            break;\n        }\n\n        depthCount++;\n    }\n\n    return depthCount;\n}\n\nvec4 getSkyColorMode7(vec2 normCoord) {\n    vec4 baseSky = vec4(SKY_COLOR_R, SKY_COLOR_G, SKY_COLOR_B, 1.0);\n    //sqrt has approximation of gamma correction ability after exponentiation????\n    vec4 skyGradient = pow(baseSky, vec4(normCoord.y * SKY_GRADIENT_STRENGTH));\n    return sqrt(skyGradient);\n}\n\nvec3 tintAndDarkenWater(vec3 currentColor, bool isSolid, int depthCount, vec2 normCoord) {\n    if(isSolid) return currentColor;\n\n    float randomOffset = 0.0;\n    //WHOA WHOA WHOA this is a if NOT defined macro check..\n    #ifndef ENABLE_LAYER_RANDOMIZATION\n        randomOffset = hash12(normCoord * LAYER_OFFSET_MULTIPLIER + iTime);\n    #endif\n\n    #ifdef ENABLE_WATER_ANIMATION\n        //interpolation for \"pretty water darkening\" study all the water stuff LAST!!!\n        float dynamicThreshold = mix(\n            WATER_ANIM_DEPTH_MIN,\n            WATER_ANIM_DEPTH_MAX,\n            WATER_ANIM_COS_OFFSET + WATER_ANIM_COS_AMPLITUDE * cos(tau * iTime * WATER_ANIM_COS_FREQUENCY)\n        );\n        if(depthCount > int(dynamicThreshold - randomOffset)) {\n            currentColor *= WATER_DARKEN_MULTIPLIER;\n        }\n    #else\n        // hmmmmm\n        if(depthCount > WATER_STATIC_DARKEN_THRESHOLD) {\n            currentColor *= WATER_DARKEN_MULTIPLIER;\n        }\n    #endif\n    \n    return currentColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Convert the fragments to normals of: x in [-aspect, aspect] and y in [-1,1]\n    // y = 0.0 is center of screen !!!!!\n    vec2 normCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // If Mode7 is on and above y is above horizon line normal, color the sky and return\n    #ifdef ENABLE_MODE7\n        if(normCoord.y >= HORIZON_LINE) {\n            fragColor = getSkyColorMode7(normCoord);\n            return; //not gonna work for godot shaders, come back to this before moving to godot \n        }\n    #endif\n\n    vec2 transformCoord = normCoord;\n\n    // default to NEAR for non-mode7 parallax\n    // this is hacky/bad design on my part because it actually results in the following:\n    //CONTROL BRANCHING DESCRIPTION:\n    //PARALLAX enabled, MODE7 enabled -> the value gets set to NEAR first, then overwritten by DISTANT and thus in\n    //    - AND LATER IN THIS FUNCTION (mainImage) the line bool fragmentIsSolid = isSolidAtCoord(transformCoord, localNoiseScale);\n    //    - isSolidAtCoord(transformCoord, localNoiseScale)'s `localNoiseScale` will be DISTANT\n    //    - this is desired and normal control branching i think (but tricky because i didnt know about that `out` keyword in glsl func params\n\n    //PARALLAX enabled, MODE7 disabled -> the value gets set to NEAR first BUT THEN gets REASSIGNED in applyLayerPerspective for seemingly unknown reasons (念の為 silliness？？？）\n    //    - AND LATER IN THIS FUNCTION (mainImage) the line bool fragmentIsSolid = isSolidAtCoord(transformCoord, localNoiseScale);\n    //    - isSolidAtCoord(transformCoord, localNoiseScale)'s `localNoiseScale` will be NEAR\n    //    - this is kind of ok i guess, no issues other than the strange seemingly unneccessary reassignment in applyLayerPerspective\n    \n    //PARALLAX disabled, MODE7 enabled -> the value gets set to NEAR first, applyLayerPerspective doesn't get called in this function (mainImage)\n    //    - LATER ON when countFluidLayers gets called, inside there applyLayerPerspective gets called\n    //    - a \"local scope\"(?)float localNoiseScale; gets declared in countFluidLayers and passed into that applyLayerPerspective,\n    //    - since MODE7 is enabled, when calling applyLayerPerspective the localNoiseScale inside the countFluidLayers scope becomes DISTANT???\n    //    - this is the bad case, because it results in two contradicting localNoiseScale in two separate scopes \n    //    - and so parallax doesnt happen in the main image function scope so the noise texture just gets overlayed flat on the screen\n    //    - BUT BECAUSE countFluidLayers is doing its own iteration of applyLayerPerspective calls, behind the flat noise texture there is a completely separate MODE7 scene almost\n    float localNoiseScale = NOISE_SCALE_NEAR; \n    \n    //TODO: PARALLAX and MODE7 being applied results in two kinds of projection processes, not sure if this is good or not yet... \n    // it could be exactly what is needed for achieving a more nuanced control over perspective \n    #ifdef ENABLE_PARALLAX\n        transformCoord = applyLayerPerspective(normCoord, localNoiseScale);\n    #endif\n\n    float perspectiveFactor = PERSPECTIVE_SCALE_NEUTRAL;\n    #ifdef ENABLE_PERSPECTIVE\n        perspectiveFactor = (PERSPECTIVE_OFFSET - normCoord.y) / PERSPECTIVE_DIVISOR;\n    #endif\n\n    float layerOffsetVal = LAYER_OFFSET_DEFAULT;\n    #ifdef ENABLE_LAYER_RANDOMIZATION\n        layerOffsetVal = hash12(normCoord * LAYER_OFFSET_MULTIPLIER + iTime);\n    #endif\n\n    //TODO: without any of the effect macros enabled, this really demonstrates the true effect of this shader\n    int fluidDepth = countFluidLayers(normCoord, perspectiveFactor, layerOffsetVal);\n\n    bool fragmentIsSolid = isSolidAtCoord(transformCoord, localNoiseScale);\n\n    vec3 color; //TODO: in the future i want to be more explicit with the channels involved\n    \n    // If current fragment is solid -> color with a near-white else -> color with the vertical face/water scheme\n    if(fragmentIsSolid) {\n        color = vec3(SOLID_REGION_BRIGHTNESS, SOLID_REGION_BRIGHTNESS, SOLID_REGION_BRIGHTNESS); //GRAYSCALE??????\n    } else {\n        //color math for pretty gradient\n        float exponent = float(fluidDepth) / WATER_DEPTH_DARKEN_DIVISOR;\n        vec3 water = vec3(WATER_COLOR_R, WATER_COLOR_G, WATER_COLOR_B);\n        color = pow(water, vec3(exponent, exponent, exponent));\n    }\n\n    #ifdef ENABLE_WATER\n        color = tintAndDarkenWater(color, fragmentIsSolid, fluidDepth, normCoord);\n    #endif\n\n    // again, i need to learn what gamma correction is....\n    color = sqrt(color);\n\n    fragColor = vec4(color.r, color.g, color.b, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define ENABLE_WATER\n\n    // \"Water\" color for the non-solid region; we raise it to a power based on the fluid depth\n    // for a subtle darkening. These are in [0,1].\n    #define WATER_COLOR_R                      0.1\n    #define WATER_COLOR_G                      0.7\n    #define WATER_COLOR_B                      0.8\n\n    // A multiplier that darkens the water color further once it exceeds a certain \"depth threshold.\"\n    #define WATER_DARKEN_MULTIPLIER           0.5\n   \n    // Used to exponentiate the water color by (depth / WATER_DEPTH_DARKEN_DIVISOR).\n    #define WATER_DEPTH_DARKEN_DIVISOR         5.0\n\n    // If water animation is off, we darken whenever the depth exceeds this static threshold.\n    #define WATER_STATIC_DARKEN_THRESHOLD     12\n    \n#define ENABLE_WATER_ANIMATION\n\n    // If water animation is on, these bounds define the range of threshold for darkening.\n    // We blend between them using a cosine wave.\n    #define WATER_ANIM_DEPTH_MIN              8.0\n    #define WATER_ANIM_DEPTH_MAX              20.0\n    \n    // Vertical shift of the cosine wave that sets the threshold, plus amplitude scale, plus frequency.\n    #define WATER_ANIM_COS_OFFSET             0.5\n    #define WATER_ANIM_COS_AMPLITUDE          0.5\n    #define WATER_ANIM_COS_FREQUENCY          0.1\n\n\n// MISC COLOR\n// Background color for the top half of the screen when MODE7 is enabled (the \"sky\").\n#define SKY_COLOR_R                        0.1\n#define SKY_COLOR_G                        0.7\n#define SKY_COLOR_B                        0.8\n\n// A multiplier for exponentiating the sky color based on the normalized Y coordinate,\n// creating a vertical gradient effect.\n#define SKY_GRADIENT_STRENGTH             15.0\n\n// The grayscale color used for solid regions (ice, ground, etc.).\n#define SOLID_REGION_BRIGHTNESS           0.9\n\n\n//MISC MATH\n#define pi 3.1415926\n#define tau (pi+pi)\n#define PI_4 0.785398163397448309615660845819875721\n\n\n\nfloat hash12(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 grad(ivec2 z)\n{\n    //return hash22(vec2(z)) * 2.0 - 1.0;\n    return hash22(vec2(z)*123.456) * 2.0 - 1.0;\n}\n\nfloat perlin_noise_iq( in vec2 p ) // Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\n    //vec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    vec2 u = smoothstep(0.0, 1.0, f);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ),\n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ),\n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n//TODO: whacked-out gpt-assisted voronoi??? I need to look into proper understanding of voronoi from other proper shaders\nfloat voronoi_edge_fast(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    float F1 = 1e9;\n    float F2 = 1e9;\n\n    vec2 OFFS[5] = vec2[5]( vec2( 0, 0),\n                            vec2(-1, 0), vec2( 1, 0),\n                            vec2( 0,-1), vec2( 0, 1) );\n\n    for(int k = 0; k < 4; ++k)\n    {\n        vec2  n   = OFFS[k];\n        vec2  seed = n + hash22(ip + n);   // jitter inside cell\n        vec2  d    = fp - seed;\n        float d2   = dot(d, d);\n\n        if(d2 < F1) { F2 = F1; F1 = d2; }\n        else if(d2 < F2) { F2 = d2; }\n    }\n\n    return sqrt(F2) - sqrt(F1);   // 0 on edge, large inside\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "33XSR8",
    "date": "1744810069",
    "viewed": 85,
    "name": "verbose icesheet",
    "description": "Beginnings of a verbose rewrite of jt's incredible icesheet shader:\n\nhttps://www.shadertoy.com/view/WXSGDt, \nhttps://www.shadertoy.com/view/WX23Dc, \nand https://www.shadertoy.com/view/t3l3R7\n\nare also forks",
    "likes": 6,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "icesheet"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//This shader is a fork and study of user www.shadertoy.com/user/jt 's works found here:\n//https://www.shadertoy.com/view/WXSGDt, \n//https://www.shadertoy.com/view/WX23Dc, \n//https://www.shadertoy.com/view/t3l3R7\n\n//please take a look at them before looking at this\n//NOTES: APRIL 17th - study what is isotropic and anisotropic, everytime i see those words my brain short circuits\n\n#define NOISE_SCROLL_VELOCITY              vec2(0.0, 0.2)\n\n//how big the noise blobs are (bigger number smaller blobs)\n#define GLOBAL_COORD_SCALAR                 80.0 \n\n#define ENABLE_STRETCH_NOISE_TEXTURE\n    //range of 1.0 to 1.5 is consistent in the stretching of the y here idk why\n    #define STRETCH_SCALAR_X                1.0\n    //elongate the y-axis of the noise texture... THIS IS BEFORE ROTATION!!!\n    #define STRETCH_SCALAR_Y                2.0\n\n#define ENABLE_ROTATION\n    //To achieve the same effect as ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS:\n    #define ROTATION_ANGLE        -PI_4\n    //#define ROTATION_ANGLE        (-PI_4 * 0.5)\n    #define ROTATION_MATRIX       mat2(cos(ROTATION_ANGLE), -sin(ROTATION_ANGLE),\\\n                                       sin(ROTATION_ANGLE),  cos(ROTATION_ANGLE))\n\n//I HAVE NO IDEA HOW THIS CORRECTION SCALAR WORKS... \n//IT COMPLETELY BLASTS THE WHOLE NOISE TEXTURE SAMPLE COORDINATES!\n//AT CERTAIN VALUES IT SEEMS TO SERVE AS A REDUNDANT decomposition of the GLOBAL_COORD_SCALAR\n//theoretically k???? where \"full\" aspect correction is:\n//k = sqrt((pow(STRETCH_SCALAR_X, 2.0) + pow(STRETCH_SCALAR_Y, 2.0)) / 2.0) ??????\n#define ENABLE_PRE_ROTATION_STRETCH_CORRECTION\n    //To achieve the same effect as ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS:\n    #define UNIFORM_CORRECTION_SCALAR sqrt(2.0) \n    //#define UNIFORM_CORRECTION_SCALAR (sqrt((pow(STRETCH_SCALAR_X, 2.0) + pow(STRETCH_SCALAR_Y, 2.0)) / 2.0))\n    //#define UNIFORM_CORRECTION_SCALAR 1.0\n\n#define ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS (correction with rotation...)    \n    #define UNIFORM_SCALE_ROTATION_COMPOSED mat2(1.0,  1.0,  \\\n                                                -1.0,  1.0)\n//controls the amount of boundary between solid (ice) and non-solids(gaps/crevaces)\n//domain is dangerous [-0.11, 0.46]??? (stuff that goes too low in the negatives will crash firefox\n//FRAME RATE DIPS when trying even -0.11, more than that you risk crashing\n// to make the whole shttps://www.shadertoy.com/img/themes/dark/play.pngheet fully WHITE its somewhere around like 0.45~0.46\n//good range is like -0.1 ~ 0.1 if you want at least some interesting crevace shapes\n//IAN -- idea: whoa what if we could modulate this within different quadrants of the texture for more control over boundary patterns through out??????!!!!\n#define NOISE_SOLID_THRESHOLD             -0.03 //this has no effect on perspective\n\n//TODO: just another parameter to tune things with at the end (translation of sampling location kind of??\n#define NOISE_COORD_OFFSET                 vec2(2.0, 0.0) \n\nfloat sampleNoise(vec2 coord, float localNoiseScale) {\n    float x_displacement = iTime * NOISE_SCROLL_VELOCITY.x;\n    float y_displacement = iTime * NOISE_SCROLL_VELOCITY.y;\n    vec2 displaced_coordinate = vec2(\n        coord.x + x_displacement,\n        coord.y + y_displacement\n    );\n    vec2 scaled_coordinate = displaced_coordinate * GLOBAL_COORD_SCALAR;\n    vec2 stretched_coordinate = vec2(\n        scaled_coordinate.x * STRETCH_SCALAR_X,\n        scaled_coordinate.y * STRETCH_SCALAR_Y\n    );\n\n    #ifdef ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS\n        vec2 uniform_scaled_rotated_coordinate = UNIFORM_SCALE_ROTATION_COMPOSED * stretched_coordinate;\n        vec2 local_noise_scaled_coordinate = uniform_scaled_rotated_coordinate * localNoiseScale;\n    #else\n        //decompose the scaling and rotating affine transforms for more \"fine\" control\n        //TODO: idk if to correct before or after rotating...\n        vec2 uniform_scaled_coordinate = UNIFORM_CORRECTION_SCALAR * stretched_coordinate; \n        // WAH! go back to highschool ian! how could you forget that in matrix ops Order matters! R * S ≠ S * R.\n        // row_vector × matrix is a transpose! (NOT WHAT WE WANT!)\n        vec2 rotated_coordinate = ROTATION_MATRIX * uniform_scaled_coordinate; \n        vec2 local_noise_scaled_coordinate = rotated_coordinate * localNoiseScale;\n    #endif\n\n    vec2 final_noise_coordinate = local_noise_scaled_coordinate - NOISE_COORD_OFFSET;\n    float sampled_noise = perlin_noise_iq(final_noise_coordinate);\n    return sampled_noise;\n}\n\n#define ENABLE_PARALLAX \n    #define NEAR_LAYER_DIVISOR_OFFSET          2.0\n\n    //^^//TODO:::!!! find better term for \"layers\", i still dont understand how the near and far layers \n    //are working, and how perspective term is at all meaningful with these layers\n\n    //Ian note - this is really just the zoom factor of how low res we sample the noise pattern\n    //applied ONLY WHEN PARALAX IS OFF???\n    #define NOISE_SCALE_NEAR                   0.025\n    //#define NOISE_SCALE_NEAR                 0.025001 \n\n#define ENABLE_MODE7 //this is the only macro that seems to control what i am percieving as \"PERSPECTIVE\"\n\n    //DISTANT_LAYER_VERTICAL_OFFSET + HORIZON_LINE == 1.0 must be true for alignment \n    #define HORIZON_LINE                       0.75\n    \n    //see HORIZON_LINE\n    //applied ONLY when MODE7 is on\n    #define DISTANT_LAYER_VERTICAL_OFFSET       0.25\n    \n    #define DISTANT_LAYER_DIVISOR_OFFSET       1.0\n\n    #define NOISE_SCALE_DISTANT                0.005\n\n//TODO: Enabling perspective is bizzare i dont get how it works\n//its more just like a \"darkening factor\" on the icesheets vertical faces/sidewalls\n//it also has an effect on the water's height: when water is on and then turn on perspective, the water line gets higher\n//Perhaps its relationship with MODE7 is where it becomes important??\n#define ENABLE_PERSPECTIVE \n\n    // Used if perspective is enabled: final scale factor = (PERSPECTIVE_OFFSET - y) / PERSPECTIVE_DIVISOR\n    // This moves the apparent horizon as y changes.\n    #define PERSPECTIVE_OFFSET                 2.0\n    #define PERSPECTIVE_DIVISOR                3.0\n\n    // Default scale factor if perspective is disabled. (No extra vertical scaling.)\n    #define PERSPECTIVE_SCALE_NEUTRAL          1.0\n\n//#define ENABLE_LAYER_RANDOMIZATION //no idea how this works, ignore for now\n    #define LAYER_OFFSET_MULTIPLIER            123.456\n\n    #define LAYER_OFFSET_DEFAULT               0.0\n\n\nbool isSolidAtCoord(vec2 coord, float localNoiseScale) {\n    float noiseValue = sampleNoise(coord, localNoiseScale);\n    return (noiseValue < NOISE_SOLID_THRESHOLD);\n}\n\n// !!!!!!!1this function actually INSTANTIATES the chosenNoiseScale that will be used anywhere \n//down the line in the code after this function is called!!!!!!!!!!!!!!!!!!!!!!!\nvec2 applyLayerPerspective(vec2 originalCoord, out float chosenNoiseScale) {\n    #ifdef ENABLE_MODE7\n        chosenNoiseScale = NOISE_SCALE_DISTANT;\n        originalCoord.y += DISTANT_LAYER_VERTICAL_OFFSET;\n        originalCoord = originalCoord / (DISTANT_LAYER_DIVISOR_OFFSET - originalCoord.y);\n    #else\n        chosenNoiseScale = NOISE_SCALE_NEAR;\n        originalCoord = originalCoord / (NEAR_LAYER_DIVISOR_OFFSET - originalCoord.y);\n    #endif\n    return originalCoord;\n}\n\nint countFluidLayers(vec2 normalizedCoord, float perspectiveFactor, float layerOffset){\n    int depthCount = 0;\n    \n    while(true) {\n        float depthAsFloat = float(depthCount) + layerOffset;\n        \n        vec2 testCoord = normalizedCoord + vec2(0.0, depthAsFloat / GLOBAL_COORD_SCALAR) * perspectiveFactor;\n        \n        // WHYYYY DO WE HAVE TO re-apply the parallax/perspective transform HERE????\n        float localNoiseScale;\n        vec2 finalCoord = applyLayerPerspective(testCoord, localNoiseScale);\n\n        if(isSolidAtCoord(finalCoord, localNoiseScale)) {\n            break;\n        }\n\n        if(normalizedCoord.y + (float(depthCount) / GLOBAL_COORD_SCALAR) >= iResolution.y) {\n            break;\n        }\n\n        depthCount++;\n    }\n\n    return depthCount;\n}\n\nvec4 getSkyColorMode7(vec2 normCoord) {\n    vec4 baseSky = vec4(SKY_COLOR_R, SKY_COLOR_G, SKY_COLOR_B, 1.0);\n    //sqrt has approximation of gamma correction ability after exponentiation????\n    vec4 skyGradient = pow(baseSky, vec4(normCoord.y * SKY_GRADIENT_STRENGTH));\n    return sqrt(skyGradient);\n}\n\nvec3 tintAndDarkenWater(vec3 currentColor, bool isSolid, int depthCount, vec2 normCoord) {\n    if(isSolid) return currentColor;\n\n    float randomOffset = 0.0;\n    //WHOA WHOA WHOA this is a if NOT defined macro check..\n    #ifndef ENABLE_LAYER_RANDOMIZATION\n        randomOffset = hash12(normCoord * LAYER_OFFSET_MULTIPLIER + iTime);\n    #endif\n\n    #ifdef ENABLE_WATER_ANIMATION\n        //interpolation for \"pretty water darkening\" study all the water stuff LAST!!!\n        float dynamicThreshold = mix(\n            WATER_ANIM_DEPTH_MIN,\n            WATER_ANIM_DEPTH_MAX,\n            WATER_ANIM_COS_OFFSET + WATER_ANIM_COS_AMPLITUDE * cos(tau * iTime * WATER_ANIM_COS_FREQUENCY)\n        );\n        if(depthCount > int(dynamicThreshold - randomOffset)) {\n            currentColor *= WATER_DARKEN_MULTIPLIER;\n        }\n    #else\n        // hmmmmm\n        if(depthCount > WATER_STATIC_DARKEN_THRESHOLD) {\n            currentColor *= WATER_DARKEN_MULTIPLIER;\n        }\n    #endif\n    \n    return currentColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Convert the fragments to normals of: x in [-aspect, aspect] and y in [-1,1]\n    // y = 0.0 is center of screen !!!!!\n    vec2 normCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // If Mode7 is on and above y is above horizon line normal, color the sky and return\n    #ifdef ENABLE_MODE7\n        if(normCoord.y >= HORIZON_LINE) {\n            fragColor = getSkyColorMode7(normCoord);\n            return; //not gonna work for godot shaders, come back to this before moving to godot \n        }\n    #endif\n\n    vec2 transformCoord = normCoord;\n\n    // default to NEAR for non-mode7 parallax\n    // this is hacky/bad design on my part because it actually results in the following:\n    //CONTROL BRANCHING DESCRIPTION:\n    //PARALLAX enabled, MODE7 enabled -> the value gets set to NEAR first, then overwritten by DISTANT and thus in\n    //    - AND LATER IN THIS FUNCTION (mainImage) the line bool fragmentIsSolid = isSolidAtCoord(transformCoord, localNoiseScale);\n    //    - isSolidAtCoord(transformCoord, localNoiseScale)'s `localNoiseScale` will be DISTANT\n    //    - this is desired and normal control branching i think (but tricky because i didnt know about that `out` keyword in glsl func params\n\n    //PARALLAX enabled, MODE7 disabled -> the value gets set to NEAR first BUT THEN gets REASSIGNED in applyLayerPerspective for seemingly unknown reasons (念の為 silliness？？？）\n    //    - AND LATER IN THIS FUNCTION (mainImage) the line bool fragmentIsSolid = isSolidAtCoord(transformCoord, localNoiseScale);\n    //    - isSolidAtCoord(transformCoord, localNoiseScale)'s `localNoiseScale` will be NEAR\n    //    - this is kind of ok i guess, no issues other than the strange seemingly unneccessary reassignment in applyLayerPerspective\n    \n    //PARALLAX disabled, MODE7 enabled -> the value gets set to NEAR first, applyLayerPerspective doesn't get called in this function (mainImage)\n    //    - LATER ON when countFluidLayers gets called, inside there applyLayerPerspective gets called\n    //    - a \"local scope\"(?)float localNoiseScale; gets declared in countFluidLayers and passed into that applyLayerPerspective,\n    //    - since MODE7 is enabled, when calling applyLayerPerspective the localNoiseScale inside the countFluidLayers scope becomes DISTANT???\n    //    - this is the bad case, because it results in two contradicting localNoiseScale in two separate scopes \n    //    - and so parallax doesnt happen in the main image function scope so the noise texture just gets overlayed flat on the screen\n    //    - BUT BECAUSE countFluidLayers is doing its own iteration of applyLayerPerspective calls, behind the flat noise texture there is a completely separate MODE7 scene almost\n    float localNoiseScale = NOISE_SCALE_NEAR; \n    \n    //TODO: PARALLAX and MODE7 being applied results in two kinds of projection processes, not sure if this is good or not yet... \n    // it could be exactly what is needed for achieving a more nuanced control over perspective \n    #ifdef ENABLE_PARALLAX\n        transformCoord = applyLayerPerspective(normCoord, localNoiseScale);\n    #endif\n\n    float perspectiveFactor = PERSPECTIVE_SCALE_NEUTRAL;\n    #ifdef ENABLE_PERSPECTIVE\n        perspectiveFactor = (PERSPECTIVE_OFFSET - normCoord.y) / PERSPECTIVE_DIVISOR;\n    #endif\n\n    float layerOffsetVal = LAYER_OFFSET_DEFAULT;\n    #ifdef ENABLE_LAYER_RANDOMIZATION\n        layerOffsetVal = hash12(normCoord * LAYER_OFFSET_MULTIPLIER + iTime);\n    #endif\n\n    int fluidDepth = countFluidLayers(normCoord, perspectiveFactor, layerOffsetVal);\n\n    bool fragmentIsSolid = isSolidAtCoord(transformCoord, localNoiseScale);\n\n    vec3 color; //TODO: in the future i want to be more explicit with the channels involved\n    \n    // If current fragment is solid -> color with a near-white else -> color with the vertical face/water scheme\n    if(fragmentIsSolid) {\n        color = vec3(SOLID_REGION_BRIGHTNESS, SOLID_REGION_BRIGHTNESS, SOLID_REGION_BRIGHTNESS); //GRAYSCALE??????\n    } else {\n        //color math for pretty gradient\n        float exponent = float(fluidDepth) / WATER_DEPTH_DARKEN_DIVISOR;\n        vec3 water = vec3(WATER_COLOR_R, WATER_COLOR_G, WATER_COLOR_B);\n        color = pow(water, vec3(exponent, exponent, exponent));\n    }\n\n    #ifdef ENABLE_WATER\n        color = tintAndDarkenWater(color, fragmentIsSolid, fluidDepth, normCoord);\n    #endif\n\n    // again, i need to learn what gamma correction is....\n    color = sqrt(color);\n\n    fragColor = vec4(color.r, color.g, color.b, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define ENABLE_WATER\n\n    // \"Water\" color for the non-solid region; we raise it to a power based on the fluid depth\n    // for a subtle darkening. These are in [0,1].\n    #define WATER_COLOR_R                      0.1\n    #define WATER_COLOR_G                      0.7\n    #define WATER_COLOR_B                      0.8\n\n    // A multiplier that darkens the water color further once it exceeds a certain \"depth threshold.\"\n    #define WATER_DARKEN_MULTIPLIER           0.5\n   \n    // Used to exponentiate the water color by (depth / WATER_DEPTH_DARKEN_DIVISOR).\n    #define WATER_DEPTH_DARKEN_DIVISOR         5.0\n\n    // If water animation is off, we darken whenever the depth exceeds this static threshold.\n    #define WATER_STATIC_DARKEN_THRESHOLD     12\n    \n//#define ENABLE_WATER_ANIMATION\n\n    // If water animation is on, these bounds define the range of threshold for darkening.\n    // We blend between them using a cosine wave.\n    #define WATER_ANIM_DEPTH_MIN              1.0\n    #define WATER_ANIM_DEPTH_MAX              40.0\n    \n    // Vertical shift of the cosine wave that sets the threshold, plus amplitude scale, plus frequency.\n    #define WATER_ANIM_COS_OFFSET             0.5\n    #define WATER_ANIM_COS_AMPLITUDE          0.5\n    #define WATER_ANIM_COS_FREQUENCY          0.1\n\n\n// MISC COLOR\n// Background color for the top half of the screen when MODE7 is enabled (the \"sky\").\n#define SKY_COLOR_R                        0.1\n#define SKY_COLOR_G                        0.7\n#define SKY_COLOR_B                        0.8\n\n// A multiplier for exponentiating the sky color based on the normalized Y coordinate,\n// creating a vertical gradient effect.\n#define SKY_GRADIENT_STRENGTH             15.0\n\n// The grayscale color used for solid regions (ice, ground, etc.).\n#define SOLID_REGION_BRIGHTNESS           0.9\n\n\n//MISC MATH\n#define pi 3.1415926\n#define tau (pi+pi)\n#define PI_4 0.785398163397448309615660845819875721\n\n\n\nfloat hash12(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 grad(ivec2 z)\n{\n    //return hash22(vec2(z)) * 2.0 - 1.0;\n    return hash22(vec2(z)*123.456) * 2.0 - 1.0;\n}\n\nfloat perlin_noise_iq( in vec2 p ) // Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\n    //vec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    vec2 u = smoothstep(0.0, 1.0, f);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ),\n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ),\n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXlXRj",
    "date": "1745300625",
    "viewed": 29,
    "name": "borked perspective tilt",
    "description": "bleh",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sprites"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rn",
       "filepath": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define MAXIMUM_TILT_ANGLE_ACHIEVED_AT_IMMEDIATE_ASCENSION_AND_FINAL_DESCENT 0.785398 // 45° in radians\n#define MIDPOINT_UV 0.5\n#define FOCAL_LENGTH 1.0\n\nconst int spriteSheetChannelIndex = 0;\nconst int backgroundChannelIndex = 1;\n\nconst vec3 backgroundColor = vec3(0.0, 52.0 / 255.0, 102.0 / 255.0);\nconst vec2 spriteSize = vec2(36.0, 22.0);\nconst vec2 spriteOffset = vec2(1.0, 5.0);\nconst vec2 spriteSpacing = vec2(4.0, 0.0);\nconst int columns = 6;\nconst float spriteScale = 1.5; // shrink to 50%\n\n\n// Pick static frame (e.g., frame 0)\nconst int spriteFrameIndex = 0;\n\n// Alpha-blended texture sampler\nvec3 alphaBlendChannel(int channelIndex, vec2 uv, vec3 backColor) {\n    vec4 color = vec4(backColor, 1.0);\n    if (channelIndex == 0) color = texture(iChannel0, uv);\n    if (channelIndex == 1) color = texture(iChannel1, uv);\n    return mix(backColor, color.rgb, color.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 resolution = iResolution.xy;\n    vec2 uv = fragCoord.xy / resolution.xy;\n\n    // Jump cycle: 2s sine wave (altitude_normal: 0 → 1 → 0)\n    float cyclePhase = mod(iTime, 2.0) / 2.0;\n    float altitude_normal = sin(cyclePhase * 3.14159);\n    bool ascending = cyclePhase < 0.5;\n\n    // If grounded, no tilt\n    if (altitude_normal <= 0.0 || MAXIMUM_TILT_ANGLE_ACHIEVED_AT_IMMEDIATE_ASCENSION_AND_FINAL_DESCENT <= 0.0) {\n        // Sample frame from sprite sheet (unwarped)\n        vec2 frameOffset = spriteOffset + vec2(\n            mod(float(spriteFrameIndex), float(columns)) * (spriteSize.x + spriteSpacing.x),\n            floor(float(spriteFrameIndex) / float(columns)) * (spriteSize.y + spriteSpacing.y)\n        );\n\n        vec2 spriteUV = ((uv - 0.5) * spriteScale + 0.5) * spriteSize + frameOffset;\n        spriteUV /= iChannelResolution[spriteSheetChannelIndex].xy;\n        vec3 spriteColor = alphaBlendChannel(spriteSheetChannelIndex, spriteUV, backgroundColor);\n        fragColor = vec4(spriteColor, 1.0);\n        return;\n    }\n\n    // 1) normalized 0->1 fraction through jump cycle (0 = lift‑off/land, 1 = apex, back to 0 for landing)\n    float jump_phase_progress = altitude_normal;\n    // 2) how much ground‑tilt remains (1 = full tilt on ground, 0 = no tilt at apex)\n    float sprite_tilt_phase_progress = 1.0 - jump_phase_progress;\n    // 3) TODO: this is still hurting my head\n    float current_tilt_angle = (1.0 - jump_phase_progress) * MAXIMUM_TILT_ANGLE_ACHIEVED_AT_IMMEDIATE_ASCENSION_AND_FINAL_DESCENT;\n    // 4) TODO: idk why but it needs to happen... because of the mess i got myself into up until not\n    current_tilt_angle = -1.0 * current_tilt_angle; \n    // 6) horizontal UV offset from center (0.5)\n    float midpoint_uv_x_of_sprite_quad = uv.x - MIDPOINT_UV;\n    float cosine_of_tilt_angle = cos(current_tilt_angle);\n    float sine_of_tilt_angle   = sin(current_tilt_angle);\n    float L = uv.y;\n    //float L = ascending ? uv.y : 1.0 - uv.y;\n    if (ascending) {\n        // Flip the pivot basis for the tilt — switch from bottom to top.\n        L = 1.0 - uv.y;\n    }\n    // 6) sprite_quad_height_after_tilt_applied = L × cos(θ)\n    float sprite_quad_height_after_tilt_applied = L * cosine_of_tilt_angle;\n    // 7) sprite_quad_depth_after_tilt = L × sin(θ)\n    float sprite_quad_depth_after_tilt = L * sine_of_tilt_angle;\n    float perspective_asymptotic_scalar =\n        1.0 + sprite_quad_depth_after_tilt / FOCAL_LENGTH;\n    float projected_y_verticality_from_perspective_tilt =\n        sprite_quad_height_after_tilt_applied / perspective_asymptotic_scalar;\n    float projected_x_horizontal_squish_from_perspective_tilt =\n        midpoint_uv_x_of_sprite_quad / perspective_asymptotic_scalar;\n\n    vec2 projected_uv;\n    projected_uv.x = projected_x_horizontal_squish_from_perspective_tilt + MIDPOINT_UV;\n    projected_uv.y = !ascending\n            ? projected_y_verticality_from_perspective_tilt\n            : 1.0 - projected_y_verticality_from_perspective_tilt;\n    // 13) discard samples that fall at least 1 pixel outside of the projected texture’s new bounds \n    float one_pixel_uv_width  = 1.0 / resolution.x;\n    float one_pixel_uv_height = 1.0 / resolution.y;\n    if (projected_uv.x < one_pixel_uv_width \n        || projected_uv.x > 1.0 - one_pixel_uv_width \n        || projected_uv.y < one_pixel_uv_height \n        || projected_uv.y > 1.0 - one_pixel_uv_height) {\n        discard;\n    }\n\n    // Convert warped local UV into sheet UV\n    vec2 frameOffset = spriteOffset + vec2(\n        mod(float(spriteFrameIndex), float(columns)) * (spriteSize.x + spriteSpacing.x),\n        floor(float(spriteFrameIndex) / float(columns)) * (spriteSize.y + spriteSpacing.y)\n    );\n    vec2 spriteUV = ((projected_uv - 0.5) * spriteScale + 0.5) * spriteSize + frameOffset;\n    spriteUV /= iChannelResolution[spriteSheetChannelIndex].xy;\n    vec3 spriteColor = alphaBlendChannel(spriteSheetChannelIndex, spriteUV, backgroundColor);\n    fragColor = vec4(spriteColor, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XfSDX",
    "date": "1745552748",
    "viewed": 60,
    "name": "final draft verbose jt ice study",
    "description": " final draft of verbose rewrite study of jt's shaders:\nhttps://www.shadertoy.com/view/WXSGDt\nhttps://www.shadertoy.com/view/WX23Dc\nhttps://www.shadertoy.com/view/t3l3R7",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "noise",
     "parallax",
     "study",
     "mode7"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// This shader is a fork/verbose rewrite of user Jakob Thomsen's 2025 MIT liscensed works found here:\n// www.shadertoy.com/user/jt\n// https://www.shadertoy.com/view/WXSGDt \n// https://www.shadertoy.com/view/WX23Dc \n// https://www.shadertoy.com/view/t3l3R7\n\n// NOTE: There is some commented out Godot code throughout, if interested, see gdshader ports here:\n// https://github.com/meisei4/bath/tree/main/Resources/Shaders/Glacier\n\n//shader_type canvas_item;\n//#include \"res://Resources/Shaders/Glacier/noise_applied.gdshaderinc\"\n//#include \"res://Resources/Shaders/Glacier/color.gdshaderinc\"\n//uniform vec2 iResolution;\n\n// NOTE: Please only disable parallax if you want to just see the raw noise textures overlayed\n// but keep in mind there is no gating to prevent the depth march, \n#define ENABLE_PARALLAX\n    #define PARALLAX_PROJECTION_ASYMPTOTIC_DEPTH_SCALAR 6.0\n    #define PARALLAX_NEAR_SCALAR                        0.025\n\n#define ENABLE_MODE7\n    #define HORIZON_LINE_ZERO_SCREEN_CENTER_UV_ADDITIVE 0.75\n    #define MODE7_VERTICAL_ADDITIVE_SCALAR              0.25\n    #define MODE7_PROJECTION_ASYMPTOTIC_DEPTH_SCALAR    1.0\n    #define MODE7_FAR_SCALAR                            0.005\n\n#define CONSTANT_DEPTH_MARCH_STRIDE_LENGTH              1.0\n#define ENABLE_VARIABLE_STRIDE_LENGTH_FOR_DEPTH_MARCH\n    #define VARIABLE_STRIDE_LENGTH_INITIAL_VALUE        2.0\n    #define VARIABLE_STRIDE_COMPRESSION_RATE            3.0\n\nvec2 projectLayer(vec2 originalCoord, out float chosenNoiseScale) {\n    #ifdef ENABLE_MODE7\n        chosenNoiseScale = MODE7_FAR_SCALAR;\n        originalCoord.y += MODE7_VERTICAL_ADDITIVE_SCALAR;\n        originalCoord = originalCoord / (MODE7_PROJECTION_ASYMPTOTIC_DEPTH_SCALAR - originalCoord.y);\n    #else\n        chosenNoiseScale = PARALLAX_NEAR_SCALAR;\n        originalCoord = originalCoord / (PARALLAX_PROJECTION_ASYMPTOTIC_DEPTH_SCALAR - originalCoord.y);\n    #endif\n    return originalCoord;\n}\n\nint depthMarch(vec2 normalizedCoord, float strideLength, float firstStepOffset){\n    int depthCount = 0;\n    while(true) {\n        float firstStep = float(depthCount) + firstStepOffset;\n        vec2 nextStep = normalizedCoord + vec2(0.0, firstStep / GLOBAL_COORD_SCALAR) * strideLength;\n        float localNoiseScale;\n        vec2 projectedCoord = projectLayer(nextStep, localNoiseScale);\n        if(isSolidAtCoord(projectedCoord, localNoiseScale, iTime)) {\n            break;\n        }\n        if(normalizedCoord.y + (float(depthCount) / GLOBAL_COORD_SCALAR) >= iResolution.y) {\n            break;\n        }\n        depthCount++;\n    }\n    return depthCount;\n}\n\nvec2 projectTopLayerForParallax(vec2 normCoord, out float noiseScale) {\n    #ifdef ENABLE_PARALLAX\n        return projectLayer(normCoord, noiseScale);\n    #else\n        noiseScale = PARALLAX_NEAR_SCALAR;\n        return normCoord;\n    #endif\n}\n\nfloat getStrideLength(vec2 normCoord) {\n    #ifdef ENABLE_VARIABLE_STRIDE_LENGTH_FOR_DEPTH_MARCH\n        return (VARIABLE_STRIDE_LENGTH_INITIAL_VALUE - normCoord.y) / VARIABLE_STRIDE_COMPRESSION_RATE;\n    #else\n        return CONSTANT_DEPTH_MARCH_STRIDE_LENGTH;\n    #endif\n}\n\nvec3 getTerrainColor(bool isSolid, int depth, vec2 normCoord) {\n    if (isSolid) {\n        return vec3(SOLID_REGION_BRIGHTNESS);\n    } else {\n        float e = float(depth) / WATER_DEPTH_DARKEN_DIVISOR;\n        return pow(vec3(WATER_COLOR_R, WATER_COLOR_G, WATER_COLOR_B), vec3(e));\n    }\n}\n\nvec3 applyWater(vec3 color, bool isSolid, int depth, vec2 normCoord) {\n    #ifdef ENABLE_WATER\n        return tintAndDarkenWater(color, isSolid, depth, normCoord, iTime);\n    #else\n        return color;\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n//void fragment() {\n    vec2 normCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    //vec2 normCoord = (FRAGCOORD.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float noiseScale;\n    vec3 color;\n    #ifdef ENABLE_MODE7\n        if (normCoord.y >= HORIZON_LINE_ZERO_SCREEN_CENTER_UV_ADDITIVE){\n            color = getSkyColorMode7(normCoord).rgb;\n        } else //This funky if-else macro hack is because godot does not allow early returns in fragment shaders\n    #endif\n    {\n        vec2 projectedTopLayerCoord = projectTopLayerForParallax(normCoord, noiseScale);\n        float stride                = getStrideLength(normCoord);\n        float firstStepOffset       = getFirstStepOffset(normCoord, iTime);\n        int   depth                 = depthMarch(normCoord, stride, firstStepOffset);\n        bool  isSolid               = isSolidAtCoord(projectedTopLayerCoord, noiseScale, iTime);\n        vec3  terrain               = getTerrainColor(isSolid, depth, normCoord);\n        vec3  terrainWithWater      = applyWater(terrain, isSolid, depth, normCoord);\n        //color = terrainWithWater; //RAW give it a try... its gross... :^)\n        color = sqrt(terrainWithWater); //GAMMAMAMA CORREECCTIONNN.... GOOD\n    }\n    //COLOR = vec4(color.r, color.g, color.b, 1.0);\n    fragColor = vec4(color.r, color.g, color.b, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "//TRANSCENDENTALS\n#define M_PI     3.14159265358979323846\n#define M_PI_4   0.785398163397448309616\n#define TAU      (M_PI + M_PI)\n\n//NOISE FUNKS\nfloat hash12(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 grad(ivec2 z)\n{\n    //return hash22(vec2(z)) * 2.0 - 1.0;\n    return hash22(vec2(z)*123.456) * 2.0 - 1.0;\n}\n\nfloat perlin_noise_iq( in vec2 p ) // Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n    //vec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    vec2 u = smoothstep(0.0, 1.0, f);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ),\n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ),\n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n//whacked-out voronoi still.. will come back to voronoi concepts in future studies\nfloat voronoi_edge_fast(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float F1 = 1e9;\n    float F2 = 1e9;\n    vec2 OFFS[5] = vec2[5]( vec2( 0, 0),\n                            vec2(-1, 0), vec2( 1, 0),\n                            vec2( 0,-1), vec2( 0, 1) );\n    for(int k = 0; k < 5; ++k) {\n        vec2  n   = OFFS[k];\n        vec2  seed = n + hash22(ip + n);\n        vec2  d    = fp - seed;\n        float d2   = dot(d, d);\n\n        if(d2 < F1) { F2 = F1; F1 = d2; }\n        else if(d2 < F2) { F2 = d2; }\n    }\n    return sqrt(F2) - sqrt(F1);\n}\n\n//APPLIED NOISE FUNKS\n//#include \"res://Resources/Shaders/Glacier/color.gdshaderinc\"\n//#include \"res://Resources/Shaders/Glacier/noise_pure.gdshaderinc\"\n\n#define NOISE_SCROLL_VELOCITY       vec2(0.0, 0.1)\n#define GLOBAL_COORD_SCALAR         180.0\n\n#define STRETCH_SCALAR_X            1.0\n#define STRETCH_SCALAR_Y            2.0\n\n#define NOISE_COORD_OFFSET          vec2(2.0, 0.0)\n#define PERLIN_SOLID_THRESHOLD      -0.03\n//#define USE_VORONOI\n    #define VORONOI_SOLID_THRESHOLD 0.34\n\n#define ENABLE_ROTATION\n    #define ROTATION_ANGLE          -M_PI_4\n    //#define ROTATION_ANGLE        (-M_PI_4 * 0.5)\n    #define ROTATION_MATRIX         mat2(vec2(cos(ROTATION_ANGLE), -sin(ROTATION_ANGLE)), \\\n                                         vec2(sin(ROTATION_ANGLE),  cos(ROTATION_ANGLE)))\n\n#define ENABLE_STRETCH_CORRECTION\n    #define UNIFORM_STRETCH_CORRECTION_SCALAR    sqrt(2.0)\n    //#define UNIFORM_STRETCH_CORRECTION_SCALAR  (sqrt((pow(STRETCH_SCALAR_X, 2.0) \\\n                                                        + pow(STRETCH_SCALAR_Y, 2.0)) \\\n                                                        / 2.0))\n\n//#define ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS\n    #define UNIFORM_STRETCH_CORRECTION_AND_ROTATION_COMPOSITION mat2(vec2(1.0,  1.0), \\\n                                                                     vec2(-1.0,  1.0))\n\n#define UNIFORM_DEPTH_MARCH_FIRST_STEP_SCALAR                    0.0\n#define ENABLE_DEPTH_MARCH_FIRST_STEP_SCRAMBLING\n    #define FIRST_STEP_SCRAMBLER_SCALAR                          123.456\n    \n//DEPTH MARCH STEP SCRAMBLING EXPLANATION:\n//DISABLED:\n//───────── slice 0 ─────────   <- all fragments hit the same slice first\n//───────── slice 1 ─────────\n//───────── slice 2 ─────────\n\n//ENABLED:\n//─────┬──────────┬─────────\n//0.2  │  0.6     │ 0.95        <- each fragment starts somewhere inside slice 0\n//─────┼──────────┼─────────\n//1.2  │  1.6     │ 1.95\n//─────┼──────────┼─────────\n//2.2  │  2.6     │ 2.95\n\nfloat sampleNoise(vec2 coord, float localNoiseScale, float iTime) {\n    float x_displacement = iTime * NOISE_SCROLL_VELOCITY.x;\n    float y_displacement = iTime * NOISE_SCROLL_VELOCITY.y;\n    //float x_displacement = TIME * NOISE_SCROLL_VELOCITY.x;\n    //float y_displacement = TIME * NOISE_SCROLL_VELOCITY.y;\n    vec2 displaced_coordinate = vec2(\n        coord.x + x_displacement,\n        coord.y + y_displacement\n    );\n    vec2 scaled_coordinate = displaced_coordinate * GLOBAL_COORD_SCALAR;\n    vec2 stretched_coordinate = vec2(\n        scaled_coordinate.x * STRETCH_SCALAR_X,\n        scaled_coordinate.y * STRETCH_SCALAR_Y\n    );\n\n    #ifdef ENABLE_COMPOSED_AFFINE_TRANSFORMATIONS\n        vec2 stretch_corrected_and_rotated_coordinate = UNIFORM_STRETCH_CORRECTION_AND_ROTATION_COMPOSITION * stretched_coordinate;\n        vec2 local_noise_scaled_coordinate = stretch_corrected_and_rotated_coordinate * localNoiseScale;\n    #else\n        #ifdef ENABLE_STRETCH_CORRECTION\n            stretched_coordinate = UNIFORM_STRETCH_CORRECTION_SCALAR * stretched_coordinate;\n        #endif\n        #ifdef ENABLE_ROTATION\n            stretched_coordinate = ROTATION_MATRIX * stretched_coordinate;\n        #endif\n        vec2 local_noise_scaled_coordinate = stretched_coordinate * localNoiseScale;\n    #endif\n\n    vec2 final_noise_coordinate = local_noise_scaled_coordinate - NOISE_COORD_OFFSET;\n    #ifdef USE_VORONOI\n        float sampled_noise = voronoi_edge_fast(final_noise_coordinate);\n    #else\n        float sampled_noise = perlin_noise_iq(final_noise_coordinate);\n    #endif\n    return sampled_noise;\n}\n\nbool isSolidAtCoord(vec2 coord, float localNoiseScale, float iTime) {\n    float noiseValue = sampleNoise(coord, localNoiseScale, iTime);\n    #ifdef USE_VORONOI\n        return (noiseValue > VORONOI_SOLID_THRESHOLD);\n    #else\n        return (noiseValue < PERLIN_SOLID_THRESHOLD);\n    #endif\n}\n\n#define ENABLE_WATER\n    // pretty water color palette from: https://www.shadertoy.com/view/MlcGD7 by FabriceNeyret2\n    #define WATER_COLOR_R                 0.1\n    #define WATER_COLOR_G                 0.7\n    #define WATER_COLOR_B                 0.8\n    #define WATER_DARKEN_MULTIPLIER       0.5\n    #define WATER_DEPTH_DARKEN_DIVISOR    9.0\n    #define WATER_STATIC_DARKEN_THRESHOLD 12\n\n#define ENABLE_WATER_ANIMATION\n    #define WATER_ANIM_DEPTH_MIN          8.0\n    #define WATER_ANIM_DEPTH_MAX          30.0\n    #define WATER_ANIM_COS_OFFSET         0.5\n    #define WATER_ANIM_COS_AMPLITUDE      0.5\n    #define WATER_ANIM_COS_FREQUENCY      0.2\n\n//#define ENABLE_MODE7\n    // same as water color palette/Rayleigh scattering for sky\n    #define SKY_COLOR_R                   0.1\n    #define SKY_COLOR_G                   0.7\n    #define SKY_COLOR_B                   0.8\n    #define SKY_GRADIENT_STRENGTH         15.0\n    #define SOLID_REGION_BRIGHTNESS       0.9\n\nvec4 getSkyColorMode7(vec2 normCoord) {\n    vec4 baseSky = vec4(SKY_COLOR_R, SKY_COLOR_G, SKY_COLOR_B, 1.0);\n    vec4 skyGradient = pow(baseSky, vec4(normCoord.y * SKY_GRADIENT_STRENGTH));\n    return sqrt(skyGradient);\n}\n\nfloat getFirstStepOffset(vec2 normCoord, float iTime) {\n    #ifdef ENABLE_DEPTH_MARCH_FIRST_STEP_SCRAMBLING\n        //return hash12(normCoord * FIRST_STEP_SCRAMBLER_SCALAR + TIME);\n        return hash12(normCoord * FIRST_STEP_SCRAMBLER_SCALAR + iTime);\n    #else\n        return UNIFORM_DEPTH_MARCH_FIRST_STEP_SCALAR;\n    #endif\n}\n\nvec3 tintAndDarkenWater(vec3 currentColor, bool isSolid, int depthCount, vec2 normCoord, float iTime) {\n    if(isSolid) return currentColor;\n    float firstStepOffset = getFirstStepOffset(normCoord, iTime);\n    #ifdef ENABLE_WATER_ANIMATION\n        float dynamicThreshold = mix(\n            WATER_ANIM_DEPTH_MIN,\n            WATER_ANIM_DEPTH_MAX,\n            WATER_ANIM_COS_OFFSET + WATER_ANIM_COS_AMPLITUDE * cos(TAU * iTime * WATER_ANIM_COS_FREQUENCY)\n            //WATER_ANIM_COS_OFFSET + WATER_ANIM_COS_AMPLITUDE * cos(TAU * TIME * WATER_ANIM_COS_FREQUENCY)\n        );\n        if(depthCount > int(dynamicThreshold - firstStepOffset)) {\n            currentColor *= WATER_DARKEN_MULTIPLIER;\n        }\n    #else\n        if(depthCount > WATER_STATIC_DARKEN_THRESHOLD) {\n            currentColor *= WATER_DARKEN_MULTIPLIER;\n        }\n    #endif\n    return currentColor;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tX2XWt",
    "date": "1746703203",
    "viewed": 47,
    "name": "cotterz maxdrekker verbose study",
    "description": "first draft, need to study what jitter and anti aliasing and all that is about,also i want to try to be more strict on the discrete vs continious parts. only one macro sofar but will add more when i understand more of the math behind curves and boundaries",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "antialiasing",
     "supersampling",
     "reproductionhyperbolic",
     "weylsequence"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//this is a verbose study of cotterrzz max drecker reproduction https://www.shadertoy.com/view/33SSDm\n\n//shader_type canvas_item;\n//render_mode blend_disabled; THIS WILL MAYBE MAKE THE ALPHA CHANNEL 1.0 assignment not needed/optimized???\n//#include \"res://Resources/Shaders/Color/supersampling.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform sampler2D iChannel0: filter_nearest_mipmap, repeat_enable;\n\nconst float TEXTURE_LOD_BASE_LEVEL = 0.0;\n\nconst float GRID_COLUMNS           = 11.0;\nconst float GRID_ROWS              = 7.0;\n\nconst float LOCAL_CELL_SPACE_UPPER_AND_LOWER_BOUNDARY = 0.10;\nconst float LOCAL_CELL_SPACE_BOUNDARY_LEFT            = 0.10; // 10% margin on the left\nconst float LOCAL_CELL_SPACE_BOUNDARY_RIGHT           = 0.90; // remember this is from x origin, to achieve 10% margin on the right\nconst float LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR    = 0.10; //shift vertically by 10% of the grid's row height\n\n//TODO: try different amplitudes and perhaps figure out different curvature functions to work with\nconst float HYPERBOLIC_AMPLITUDE = 0.01;\nconst float THICKNESS_AMPLITUDE  = 200.0;\n\n#define ALPHA_CLEAR_TEXELS_OUTSIDE_CELL_BOUNDARIES(color, x, y) {                   \\\n            if ( abs(y) > LOCAL_CELL_SPACE_UPPER_AND_LOWER_BOUNDARY \\\n               || (x)   < LOCAL_CELL_SPACE_BOUNDARY_LEFT            \\\n               || (x)   > LOCAL_CELL_SPACE_BOUNDARY_RIGHT) {       \\\n                (color).a = 0.0;                               \\\n            }                                                \\\n        }\n\nvec2 compute_grid_dimensions() {\n    return vec2(GRID_COLUMNS, GRID_ROWS);\n}\n\nfloat compute_discrete_column_index(float uv_x, float grid_width_in_columns) {\n    float column_units_x = uv_x * grid_width_in_columns;\n    float discrete_column_index = floor(column_units_x);\n    return discrete_column_index;\n}\n\nfloat compute_local_cell_progress_x(float uv_x, float grid_width_in_columns) {\n    float column_units_x    = uv_x * grid_width_in_columns;\n    float local_cell_progress_x = fract(column_units_x);\n    return local_cell_progress_x;\n}\n\n/// mirrored on accident, i messed it up in ascii, fix it later, the texture gets flipped in\n/// the viewport so i messed up the orientation and that messed up my understanding of the limits...\n/*\n                                               . ^ INFINITY +∞\n                                                 |\n                                               ' |\n                                              .  |\n                                             /   |\n                                           .     |\n                                        .        |\n                                 . . .         0 |\n        <---------------.-.--*-'-'---------------+\n        | 1      . . .\n        |     .\n        |   .\n        |  /\n        | .\n        |'\n        |. -INFINITY -∞\n        v\n\nLet k (kappa?) = HYPERBOLIC_AMPLITUDE\nDefinition of compute_vertical_curvature_hyperbolic():\n    f(x) = left_curve_downwards – right_curve_upwards\n         = (k/x – k) – (k/(1–x) – k)\n         = k · (1/x – 1/(1–x))\n\n           k · (1 – 2x)\n         = ------------\n           x · (1 – x)\n\nBEHAVIOR/BOUNDS/LIMITS:\n    x -> 0:\n             k · (1)        k\n    f(x) =  ---------  =  -----  -> +∞ (+INFINITY)\n             x · (1)        x\n\n    x == 0.5:\n      numerator = k · (1 – 2 · 0.5) = 0\n            -> f(0.5) = 0\n\n    x -> 1⁻:\n      f(x) =  k · (1 – 2 · 1)      -k · (1)      –k\n             ----------------- =  --------- =  -------  -> -∞ (-INFINITY)\n                1 · (1 – x)         1 – x       1 – x\n*/\nfloat compute_horizontal_hyperbolic_curvature(float cell_progress_x) {\n    float left_curve_downwards    = HYPERBOLIC_AMPLITUDE * ((1.0 / cell_progress_x) - 1.0);\n    float right_curve_upwards     = HYPERBOLIC_AMPLITUDE * ((1.0 / (1.0 - cell_progress_x)) - 1.0);\n    float curvature               = left_curve_downwards - right_curve_upwards;\n    return curvature;\n}\n\nfloat compute_discrete_row_index(float uv_y, float vertical_row_shift_per_column, float grid_height_in_rows, float horizontal_hyperbolic_curvature) {\n    float shifted_uv_y               = uv_y + vertical_row_shift_per_column;\n    float shifted_row_units_y        = shifted_uv_y * grid_height_in_rows;\n    float curved_shifted_row_units_y = shifted_row_units_y + horizontal_hyperbolic_curvature;\n    float discrete_row_index_after_shift_and_curve = floor(curved_shifted_row_units_y);\n    return discrete_row_index_after_shift_and_curve;\n}\n\nfloat compute_local_cell_progress_y(float uv_y, float vertical_row_shift_per_column, float grid_height_in_rows, float horizontal_hyperbolic_curvature) {\n    float shifted_uv_y               = uv_y + vertical_row_shift_per_column;\n    float shifted_row_units_y        = shifted_uv_y * grid_height_in_rows;\n    float curved_shifted_row_units_y = shifted_row_units_y + horizontal_hyperbolic_curvature;\n    float local_cell_progress_y_after_shift_and_curve = fract(curved_shifted_row_units_y);\n    return local_cell_progress_y_after_shift_and_curve;\n}\n\n/*\nPhase shifted local cell space vertical CUBIC thickening\nthickest between cells, thinnest in the middle of cells\n  f(y)=y³\n                    ^ +0.125            *\n                    |                  *\n                    |                 *\n                    |                *\n                    |               *\n                    |             **\n                    |           **\n                    | 0    ****\n–0.5 ---------------+------------------ +0.5\n           ****     |\n       **           |\n     **             |\n    *               |\n   *                |\n  *                 |\n *                  |\n*                   v –0.125\n\nCUBIC THICKENING NUMERIC INTUTION:\nLocal cell Y is offset to achieve the thickness phasing between each cell VERTICALLY\n   y       y³       f(y) absolute thickness      normalized to max (0.125)\n -----   ---------   -------------------------     ------------------------\n–0.50    –0.125       0.125                          1.00\n–0.25    –0.015625    0.015625                       0.125\n–0.10    –0.001       0.001                          0.008\n–0.02    –0.000008    0.000008                       0.000064\n 0.00     0.00        0.00                           0.00\n+0.02     0.000008    0.000008                       0.000064\n+0.10     0.001       0.001                          0.008\n+0.25     0.015625    0.015625                       0.125\n+0.50     0.125       0.125                          1.00\n*/\n\nfloat compute_vertical_cubic_thickness(float local_cell_progress_y) {\n    return local_cell_progress_y * local_cell_progress_y * local_cell_progress_y;\n}\n\nvec4 sample_uv_in_grid_space(vec2 uv, vec2 grid_dimensions) {\n    float column_index                    = compute_discrete_column_index(uv.x, grid_dimensions.x);\n    float local_cell_progress_x           = compute_local_cell_progress_x(uv.x, grid_dimensions.x);\n    float horizontal_hyperbolic_curvature = compute_horizontal_hyperbolic_curvature(local_cell_progress_x);\n\n    float vertical_row_shift_per_column    = LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR * column_index;\n    float row_index                        = compute_discrete_row_index(uv.y, vertical_row_shift_per_column, grid_dimensions.y, horizontal_hyperbolic_curvature);\n    float local_cell_progress_y            = compute_local_cell_progress_y(uv.y, vertical_row_shift_per_column, grid_dimensions.y, horizontal_hyperbolic_curvature);\n\n    float phase_shifted_local_cell_progress_y = local_cell_progress_y - NORMAL_CENTER_OFFSET;\n    float vertical_cubic_thickness            = compute_vertical_cubic_thickness(phase_shifted_local_cell_progress_y);\n    float vertical_cubic_thickness_normal     = vertical_cubic_thickness / iResolution.y;\n    float amplified_vertical_thickness        = THICKNESS_AMPLITUDE * vertical_cubic_thickness_normal;\n\n    float column_normal = column_index / grid_dimensions.x;\n    float row_normal    = row_index    / grid_dimensions.y;\n    float u = column_normal;\n    float v = row_normal + amplified_vertical_thickness - vertical_row_shift_per_column;\n\n    vec4 src_color = textureLod(iChannel0, vec2(u,v), TEXTURE_LOD_BASE_LEVEL);\n    ALPHA_CLEAR_TEXELS_OUTSIDE_CELL_BOUNDARIES(src_color, local_cell_progress_x, local_cell_progress_y);\n    return src_color;\n}\n\n\nvec4 uniform_supersample(vec2 frag_coord, vec2 grid_dimensions) {\n    vec4 uniform_distribution = vec4(0.0);\n    int  remaining_subpixels_in_supersample     = UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL;\n    #ifdef DISTRIBUTE_WITH_FRACTIONAL_STEP\n        vec2  current_uniform_subpixel_position = UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET_FRACTIONAL;\n    #else\n        vec2  current_uniform_subpixel_position = UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET_ROW_MAJOR;\n    #endif\n\n    while (remaining_subpixels_in_supersample > 0) {\n        #ifdef DISTRIBUTE_WITH_FRACTIONAL_STEP\n            current_uniform_subpixel_position = position_uniform_subpixel_fractional_stepping(current_uniform_subpixel_position);\n        #else\n            current_uniform_subpixel_position = position_uniform_subpixel_normal_stepping(current_uniform_subpixel_position);\n        #endif\n        vec2 sample_coord                  = frag_coord + current_uniform_subpixel_position;\n        vec2 uv                            = sample_coord / iResolution.y;\n        uniform_distribution               = uniform_distribution + sample_uv_in_grid_space(uv, grid_dimensions);\n        remaining_subpixels_in_supersample = remaining_subpixels_in_supersample - 1;\n    }\n    return uniform_distribution / UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F;\n}\n\nvec4 jitter_supersample(vec2 frag_coord, vec2 grid_dimensions) {\n    vec4 jittered_distribution  = vec4(0.0);\n    int  remaining_subpixels_in_supersample = JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL;\n    vec2 current_jitter_subpixel_position   = JITTERED_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET;\n    while (remaining_subpixels_in_supersample > 0) {\n        current_jitter_subpixel_position    = position_jitter_subpixel(current_jitter_subpixel_position);\n        vec2 sample_coord                   = frag_coord + current_jitter_subpixel_position;\n        vec2 uv                             = sample_coord / iResolution.y;\n        jittered_distribution               = jittered_distribution + sample_uv_in_grid_space(uv, grid_dimensions);\n        remaining_subpixels_in_supersample  = remaining_subpixels_in_supersample - 1;\n    }\n    return jittered_distribution / JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F;\n}\n\n#define BORDER_CLEARING\n//void fragment() {\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    //vec2 frag_coord     = vec2(UV.x * iResolution.x,\n    //                           UV.y * iResolution.y);\n    //vec2 uv             = frag_coord / iResolution.y;\n    vec2 uv           = frag_coord / iResolution.y;\n    vec2 grid_dimensions = compute_grid_dimensions();\n    vec4 src_color = sample_uv_in_grid_space(uv, grid_dimensions);\n    #ifdef BORDER_CLEARING\n    if (src_color.a > 0.0) {\n        src_color.a = 1.0; // HARDCODE STRAIGHT ALPHA BLEND TO NOT OCCUR (i.e. destination.rgb * 0.0)\n        //COLOR = src_color;\n        frag_color = src_color;\n    } else\n    #endif //HACK...\n    {\n        #ifdef UNIFORM_SUPERSAMPLE\n            src_color = uniform_supersample(frag_coord, grid_dimensions);\n        #endif\n        #ifdef JITTERED_SUPERSAMPLE\n            src_color = jitter_supersample(frag_coord, grid_dimensions);\n        #endif\n        src_color.a = 1.0;\n        //COLOR = src_color;\n        frag_color = src_color;\n    }\n}\n\n\n//NOTES....\n\n// SPACE DENOMINATIONS:\n//1. CANVAS NORMAL UV\n//  - frag_coord ∈ [0…iResolution.xy] (pixels)\n//  - uv = frag_coord / iResolution.y ∈ [0…(iResolution.x/iResolution.y)]×[0…1]\n\n//2. LOCAL CELL NORMAL\n//  - local_cell_progress_x/y ∈ [0…1]\n//  - used by sample_uv_in_grid_space to pick which texel and apply hyperbolic/cubic warps.\n\n//3. SUBPIXEL NORMAL\n//  - store a normalized position ∈ [0…1) in current_*_subpixel_position\n//  - then subtract LOCAL_CELL_SPACE_CENTER_OFFSET (0.5) → [-0.5…+0.5] so that\n\n// IF ALL floating point numbers are integer_part + fraction_part: e.g. 1.5 = 1 + (1/2) = 1 + 0.5\n// then to get the fraction part you just do:\n//float fract(float x) {\n    //int integer_part = floor(x)\n    //float fraction_part = x - integer_part\n    //return fraction_part;\n//}\n\n\n//https://en.wikipedia.org/wiki/Supersampling\n// ^^ check out the techniques!!\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "const float NORMAL_CENTER_OFFSET   = 0.5; // center of any normal space\n\n\n#define UNIFORM_SUPERSAMPLE\n    //TODO: test different super sample resolutions\n    const int   UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL   = 64;\n    const float UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F = float(UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL);\n    const float UNIFORM_RESONATE_STEP                                       = 1.0 / sqrt(UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F);\n    const vec2  UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET_ROW_MAJOR   = vec2(NORMAL_CENTER_OFFSET);\n    #define DISTRIBUTE_WITH_FRACTIONAL_STEP\n        const float UNIFORM_RESONATE_STEP_FRACTIONAL                           = 1.0 / UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F;\n        const vec2  UNIFORM_SUPERSAMPLE_RESONATE_STEP_VECTOR_FRACTIONAL        = vec2(UNIFORM_RESONATE_STEP, UNIFORM_RESONATE_STEP_FRACTIONAL);\n        const vec2  UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET_FRACTIONAL = NORMAL_CENTER_OFFSET * UNIFORM_SUPERSAMPLE_RESONATE_STEP_VECTOR_FRACTIONAL;\n\n\n//#define JITTERED_SUPERSAMPLE\n    const int   JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL   = 64;\n    const float JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F = float(JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL);\n    const vec2  JITTERED_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET             = vec2(NORMAL_CENTER_OFFSET);\n    const float JITTERED_RESONATE_STEP_X                                     = 0.754877669;\n    const float JITTERED_RESONATE_STEP_Y                                     = 0.569840296;\n    const vec2  JITTERED_SUPERSAMPLE_RESONATE_STEP_VECTOR                    = vec2(JITTERED_RESONATE_STEP_X, JITTERED_RESONATE_STEP_Y);\n    // POTENTIAL OTHER RESONATE STEP VALUES FOR JITTER (COMMON \"IRRATIONAL\" NUMBERS OR OTHERWISE NUMBERS NON-COMMENSURATE TO 1)\n    // φ−1  = 0.6180339887 (the golden ratio minus one?)\n    // √2−1 = 0.4142135623\n    // √3−1 = 0.7320508076\n\n\nvec2 position_uniform_subpixel_fractional_stepping(vec2 current_uniform_subpixel_position) {\n    vec2 next_uniform_subpixel_position          = current_uniform_subpixel_position + UNIFORM_SUPERSAMPLE_RESONATE_STEP_VECTOR_FRACTIONAL;\n    vec2 next_uniform_subpixel_position_fraction = fract(next_uniform_subpixel_position);\n    vec2 centered_next_uniform_subpixel_position = next_uniform_subpixel_position_fraction - NORMAL_CENTER_OFFSET;\n    return centered_next_uniform_subpixel_position;\n}\n\nvec2 position_uniform_subpixel_normal_stepping(vec2 current_uniform_subpixel_position) {\n    current_uniform_subpixel_position.x         = current_uniform_subpixel_position.x + UNIFORM_RESONATE_STEP;\n    if (current_uniform_subpixel_position.x >= 1.0) {\n        current_uniform_subpixel_position.x     = current_uniform_subpixel_position.x - 1.0;\n        current_uniform_subpixel_position.y     = current_uniform_subpixel_position.y + UNIFORM_RESONATE_STEP;\n        if (current_uniform_subpixel_position.y >= 1.0) {\n            current_uniform_subpixel_position.y = current_uniform_subpixel_position.y - 1.0;\n        }\n    }\n    return current_uniform_subpixel_position;\n}\n\nvec2 position_jitter_subpixel(vec2 current_jitter_subpixel_position) {\n    // .yx???????\n    //vec2 next_jitter_subpixel_position          = current_jitter_subpixel_position + JITTERED_SUPERSAMPLE_RESONATE_STEP_VECTOR.yx;\n    vec2 next_jitter_subpixel_position          = current_jitter_subpixel_position + JITTERED_SUPERSAMPLE_RESONATE_STEP_VECTOR;\n    vec2 next_jitter_subpixel_position_fraction = fract(next_jitter_subpixel_position);\n    vec2 centered_next_jitter_subpixel_position = next_jitter_subpixel_position_fraction - NORMAL_CENTER_OFFSET;\n    return centered_next_jitter_subpixel_position;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfcGz4",
    "date": "1746867605",
    "viewed": 26,
    "name": "wack asgjfjaskdf sand ribn",
    "description": "wack not sure whaty im doing",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "wack"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//shader_type canvas_item;\n//render_mode blend_disabled;\n//#include \"res://Resources/Shaders/Color/supersampling.gdshaderinc\"\n\n//uniform vec2 iResolution;\n//uniform sampler2D iChannel0: filter_nearest_mipmap, repeat_enable;\n\n#define TEXTURE_LOD_BASE_LEVEL 7.0\n#define GRID_COLUMNS           1.125\n#define GRID_ROWS              2.0\n//#define GRID_COLUMNS             9.125 / 2.33\n//#define GRID_ROWS                7.0 / 3.0\n\n#define MARGIN 0.0 //TODO: this doesnt have enough effect for me to understand, i think its aa...\n\n#define LOCAL_CELL_SPACE_UPPER_AND_LOWER_BOUNDARY MARGIN\n#define LOCAL_CELL_SPACE_BOUNDARY_LEFT            MARGIN// 10% margin on the left\n#define LOCAL_CELL_SPACE_BOUNDARY_RIGHT           1.0 - MARGIN // remember this is from x origin, to achieve 10% margin on the right subtract from 1\n//#define LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR    0.125 //shift vertically by 10% of the grid's row height\n#define LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR    0.0125\n\n#define HYPERBOLIC_AMPLITUDE 0.008\nfloat hyper(float column_index){\n    float seed = fract(sin(column_index * 12.9898) * 43758.5453);\n    float freq = mix(0.01, 0.2, seed);\n    float phase = seed * 6.28318530718;\n    float hyper = HYPERBOLIC_AMPLITUDE * (1.0 + 0.5 * tan(iTime * freq * 6.28318530718 + phase));\n    //float hyper = HYPERBOLIC_AMPLITUDE;\n    return hyper;\n}\n\n#define THICKNESS_AMPLITUDE  39000.0\n#define NORMAL_OFFSET_MAIN   0.5\n#define ALT_SCROLL_SPEED 0.1\n\n//#define DEBUG\n\n\n#define ALPHA_CLEAR_TEXELS_OUTSIDE_CELL_BOUNDARIES(color, x, y) {  \\\n            if ( abs(y) > LOCAL_CELL_SPACE_UPPER_AND_LOWER_BOUNDARY \\\n               || (x)   < LOCAL_CELL_SPACE_BOUNDARY_LEFT            \\\n               || (x)   > LOCAL_CELL_SPACE_BOUNDARY_RIGHT) {       \\\n                (color).a = 0.0;                               \\\n            }                                                \\\n        }\n\nvec2 compute_grid_dimensions() {\n    return vec2(GRID_COLUMNS, GRID_ROWS);\n}\n\nfloat compute_discrete_column_index(float uv_x, float grid_width_in_columns) {\n    float column_units_x = uv_x * grid_width_in_columns;\n    float discrete_column_index = floor(column_units_x);\n    return discrete_column_index;\n}\n\nfloat compute_local_cell_progress_x(float uv_x, float grid_width_in_columns) {\n    float column_units_x    = uv_x * grid_width_in_columns;\n    float local_cell_progress_x = fract(column_units_x);\n    return local_cell_progress_x;\n}\n\nfloat compute_horizontal_hyperbolic_curvature(float hyperbolic_amplitude, float cell_progress_x) {\n    float left_curve_downwards    = hyperbolic_amplitude * ((1.0 / cell_progress_x) - 1.0);\n    float right_curve_upwards     = hyperbolic_amplitude * ((1.0 / (1.0 - cell_progress_x)) - 1.0);\n    float curvature               = left_curve_downwards - right_curve_upwards;\n    return curvature;\n}\n\nfloat compute_discrete_row_index(float uv_y, float vertical_row_shift_per_column, float grid_height_in_rows, float horizontal_hyperbolic_curvature) {\n    float shifted_uv_y               = uv_y + vertical_row_shift_per_column;\n    float shifted_row_units_y        = shifted_uv_y * grid_height_in_rows;\n    float curved_shifted_row_units_y = shifted_row_units_y + horizontal_hyperbolic_curvature;\n    float discrete_row_index_after_shift_and_curve = floor(curved_shifted_row_units_y);\n    return discrete_row_index_after_shift_and_curve;\n}\n\nfloat compute_local_cell_progress_y(float uv_y, float vertical_row_shift_per_column, float grid_height_in_rows, float horizontal_hyperbolic_curvature) {\n    float shifted_uv_y               = uv_y + vertical_row_shift_per_column;\n    float shifted_row_units_y        = shifted_uv_y * grid_height_in_rows;\n    float curved_shifted_row_units_y = shifted_row_units_y + horizontal_hyperbolic_curvature;\n    float local_cell_progress_y_after_shift_and_curve = fract(curved_shifted_row_units_y);\n    return local_cell_progress_y_after_shift_and_curve;\n}\n\nfloat compute_vertical_cubic_thickness(float local_cell_progress_y) {\n    return local_cell_progress_y * local_cell_progress_y * local_cell_progress_y;\n}\n\n\nvec4 debug_cell_border(float local_cell_progress_x, float local_cell_progress_y){\n    float bw = 10.0 / iResolution.y; \n    bool nearLeft   = local_cell_progress_x < bw;\n    bool nearRight  = local_cell_progress_x > 1.0 - bw;\n    bool nearBottom = local_cell_progress_y < bw;\n    bool nearTop    = local_cell_progress_y > 1.0 - bw;\n\n    if (nearLeft || nearRight || nearBottom || nearTop) {\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec4 debug_hyperbolic_curvature_visual(float column_index, float local_cell_progress_x) {\n    float curvature = compute_horizontal_hyperbolic_curvature(hyper(column_index), local_cell_progress_x);\n    float normalized = clamp((curvature / HYPERBOLIC_AMPLITUDE + 1.0) * 0.5, 0.0, 1.0);\n    return vec4(0.0, normalized, 0.0, 1.0);\n}\n\nvec4 debug_cubic_thickness_visual(float phase_shifted_local_cell_progress_y) {\n    float thickness = compute_vertical_cubic_thickness(phase_shifted_local_cell_progress_y);\n    float normalized = clamp(thickness, 0.0, 1.0);\n    return vec4(0.0, 0.0, normalized, 1.0);\n}\n\n\nvec4 debug_plot_hyperbola(float column_index, float local_x, float local_y) {\n    float curv  = compute_horizontal_hyperbolic_curvature(hyper(column_index), local_x);\n    float normC = clamp((curv / HYPERBOLIC_AMPLITUDE + 1.0) * 0.5, 0.0, 1.0);\n\n    float inner = 20.0  / iResolution.y;  \n    float outer = 10.0  / iResolution.y;   \n    float d     = abs(local_y - normC);\n\n    float dashCount = 50.0;\n    bool dash      = mod(floor(local_x * dashCount), 2.0) < 1.0;\n    bool inGap     = !dash;\n\n    if (inGap) {\n        if (d < inner) {\n            return vec4(0.5, 1.0, 0.5, 1.0);   \n        } else if (d < outer) {\n            return vec4(0.0, 0.0, 0.0, 1.0); \n        }\n    }\n    return vec4(0.0);\n}\n\nvec4 debug_plot_cubic(float local_x, float local_y) {\n    float phaseY = local_y - NORMAL_OFFSET_MAIN;\n    float thick  = compute_vertical_cubic_thickness(phaseY);\n    float normT  = clamp(thick, 0.0, 1.0);\n\n    float inner = 20.0 / iResolution.y;\n    float outer = 10.0 / iResolution.y;\n    float d     = abs(local_y - normT);\n    bool dash = mod(floor(local_x * 50.0), 2.0) < 1.0;\n\n    if (d < inner && dash) {\n        return vec4(1.0, 0.0, 0.5, 1.0);\n    } else if (d < outer) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    return vec4(0.0);\n}\n\nvec4 sample_uv_in_grid_space(vec2 uv, vec2 grid_dimensions) {\n    float column_index                    = compute_discrete_column_index(uv.x, grid_dimensions.x);\n    float local_cell_progress_x           = compute_local_cell_progress_x(uv.x, grid_dimensions.x);\n    float horizontal_hyperbolic_curvature = compute_horizontal_hyperbolic_curvature(hyper(column_index), local_cell_progress_x);\n    //float horizontal_hyperbolic_curvature = 0.0;\n    \n    float base_shift = LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR * column_index;\n    //float dir = mod(column_index, 2.0) < 1.0 ? 1.0 : -1.0;\n    //float scroll = fract(ALT_SCROLL_SPEED * iTime);\n    //float vertical_row_shift_per_column = base_shift + dir * scroll;\n/////????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\n    float seedA = fract(sin(column_index * 12.9898) * 43758.5453);\n    float seedB = fract(sin((column_index + 1.0) * 78.233)  * 24642.6345);\n    float freq = mix(0.007, 0.02, seedA);\n    float phase = seedB * 6.28318530718;\n    float base_speed = mix(0.02, 0.008, seedA);\n    float amp = base_speed * 10.0;\n    float disp_base = base_speed * iTime;\n    float disp_osc  = amp / freq * (1.0 - tan(freq * iTime + phase));\n    float dir = seedB < 0.5 ? 1.0 : -1.0;\n    float vertical_row_shift_per_column = base_shift + dir * (disp_base + disp_osc);\n/////??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\n    float row_index                        = compute_discrete_row_index(uv.y, vertical_row_shift_per_column, grid_dimensions.y, horizontal_hyperbolic_curvature);\n    float local_cell_progress_y            = compute_local_cell_progress_y(uv.y, vertical_row_shift_per_column, grid_dimensions.y, horizontal_hyperbolic_curvature);\n\n    float phase_shifted_local_cell_progress_y = local_cell_progress_y - NORMAL_OFFSET_MAIN;\n    float vertical_cubic_thickness            = compute_vertical_cubic_thickness(phase_shifted_local_cell_progress_y);\n    //float vertical_cubic_thickness = 0.0;\n    float vertical_cubic_thickness_normal     = vertical_cubic_thickness / iResolution.y;\n    float amplified_vertical_thickness        = THICKNESS_AMPLITUDE * vertical_cubic_thickness_normal;\n\n    float column_normal = column_index / grid_dimensions.x;\n    float row_normal    = row_index    / grid_dimensions.y;\n    float u = column_normal;\n    float v = row_normal + amplified_vertical_thickness - vertical_row_shift_per_column;\n    \n    vec4 texture_color = textureLod(iChannel0, vec2(u,v), TEXTURE_LOD_BASE_LEVEL);\n    \n    ALPHA_CLEAR_TEXELS_OUTSIDE_CELL_BOUNDARIES(texture_color, local_cell_progress_x, local_cell_progress_y);\n    \n    vec4 src_color = texture_color;\n    \n    #ifdef DEBUG\n        vec4 hyper_debug  = debug_hyperbolic_curvature_visual(column_index, local_cell_progress_x);\n        vec4 cubic_debug  = debug_cubic_thickness_visual(local_cell_progress_y);\n        vec4 border_debug = debug_cell_border(local_cell_progress_x, local_cell_progress_y);\n        vec4 hyperplot_debug  = debug_plot_hyperbola(column_index, local_cell_progress_x, local_cell_progress_y);\n        vec4 cubicplot_debug  = debug_plot_cubic(local_cell_progress_x, local_cell_progress_y);\n\n        if (border_debug.a > 0.0) {\n            src_color = border_debug;\n        }\n        if (cubicplot_debug.a > 0.0) {\n            src_color = cubicplot_debug;\n        }\n        if (hyperplot_debug.a > 0.0) {\n            src_color = hyperplot_debug;\n        }\n        //src_color += hyper_debug;\n        //src_color += cubic_debug;\n    #endif\n    return src_color;\n}\n\n\nvec4 uniform_supersample(vec2 frag_coord, vec2 grid_dimensions) {\n    vec4 uniform_distribution = vec4(0.0);\n    int  remaining_subpixels_in_supersample = UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL;\n    vec2  current_uniform_subpixel_position = INITIAL_UNIFORM_STEP;\n    while (remaining_subpixels_in_supersample > 0) {\n        current_uniform_subpixel_position = UNIFORM_STEP(current_uniform_subpixel_position);\n        vec2 sample_coord                  = frag_coord + current_uniform_subpixel_position;\n        vec2 uv                            = sample_coord / iResolution.y;\n        uniform_distribution               = uniform_distribution + sample_uv_in_grid_space(uv, grid_dimensions);\n        remaining_subpixels_in_supersample = remaining_subpixels_in_supersample - 1;\n    }\n    return uniform_distribution / UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F;\n}\n\nvec4 jitter_supersample(vec2 frag_coord, vec2 grid_dimensions) {\n    vec4 jittered_distribution  = vec4(0.0);\n    int  remaining_subpixels_in_supersample = JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL;\n    vec2 current_jitter_subpixel_position   = JITTERED_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET;\n    while (remaining_subpixels_in_supersample > 0) {\n        current_jitter_subpixel_position    = position_jitter_subpixel(current_jitter_subpixel_position);\n        vec2 sample_coord                   = frag_coord + current_jitter_subpixel_position;\n        vec2 uv                             = sample_coord / iResolution.y;\n        jittered_distribution               = jittered_distribution + sample_uv_in_grid_space(uv, grid_dimensions);\n        remaining_subpixels_in_supersample  = remaining_subpixels_in_supersample - 1;\n    }\n    return jittered_distribution / JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F;\n}\n\n#define SUPERSAMPLE(frag_coord, grid_dimensions)   jitter_supersample(frag_coord, grid_dimensions)\n//#define SUPERSAMPLE(frag_coord, grid_dimensions) uniform_supersample(frag_coord, grid_dimensions)\n\n//void fragment() {\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv           = frag_coord / iResolution.y;\n    vec2 grid_dimensions = compute_grid_dimensions();\n    vec4 src_color = sample_uv_in_grid_space(uv, grid_dimensions);\n    if (src_color.a > 0.0) {\n        frag_color = src_color;\n    } else {\n        src_color = SUPERSAMPLE(frag_coord, grid_dimensions);\n        //COLOR = src_color;\n        frag_color = src_color;\n    }\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define NORMAL_CENTER_OFFSET   0.25 // center of any normal space\n#define UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL   64\n#define UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F float(UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL)\n\n#define UNIFORM_RESONATE_STEP                                     1.0 / sqrt(UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F)\n#define UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET_ROW_MAJOR vec2(NORMAL_CENTER_OFFSET)\n//#define INITIAL_UNIFORM_STEP                                    UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_ROW_MAJOR\n//#define UNIFORM_STEP(current_uniform_subpixel_position)         position_uniform_subpixel_normal_stepping(current_uniform_subpixel_position)\n\n#define UNIFORM_RESONATE_STEP_FRACTIONAL                            1.0 / UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F\n#define UNIFORM_SUPERSAMPLE_RESONATE_STEP_VECTOR_FRACTIONAL        vec2(UNIFORM_RESONATE_STEP, UNIFORM_RESONATE_STEP_FRACTIONAL)\n#define UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET_FRACTIONAL NORMAL_CENTER_OFFSET * UNIFORM_SUPERSAMPLE_RESONATE_STEP_VECTOR_FRACTIONAL\n#define INITIAL_UNIFORM_STEP                                        UNIFORM_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET_FRACTIONAL\n#define UNIFORM_STEP(current_uniform_subpixel_position)             position_uniform_subpixel_fractional_stepping(current_uniform_subpixel_position)\n\n#define JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL   64\n#define JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F float(JITTERED_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL)\n#define JITTERED_SUPERSAMPLE_DISTRIBUTION_INITIAL_OFFSET             vec2(NORMAL_CENTER_OFFSET)\n#define JITTERED_RESONATE_STEP_X                                     0.754877669\n#define JITTERED_RESONATE_STEP_Y                                     0.569840296\n#define JITTERED_SUPERSAMPLE_RESONATE_STEP_VECTOR                    vec2(JITTERED_RESONATE_STEP_X, JITTERED_RESONATE_STEP_Y)\n// POTENTIAL OTHER RESONATE STEP VALUES FOR JITTER (COMMON \"IRRATIONAL\" NUMBERS OR OTHERWISE NUMBERS NON-COMMENSURATE TO 1)\n// φ−1  = 0.6180339887 (the golden ratio minus one?)\n// √2−1 = 0.4142135623\n// √3−1 = 0.7320508076\n\nvec2 position_uniform_subpixel_fractional_stepping(vec2 current_uniform_subpixel_position) {\n    vec2 next_uniform_subpixel_position          = current_uniform_subpixel_position + UNIFORM_SUPERSAMPLE_RESONATE_STEP_VECTOR_FRACTIONAL;\n    vec2 next_uniform_subpixel_position_fraction = fract(next_uniform_subpixel_position);\n    vec2 centered_next_uniform_subpixel_position = next_uniform_subpixel_position_fraction - NORMAL_CENTER_OFFSET;\n    return centered_next_uniform_subpixel_position;\n}\n\nvec2 position_uniform_subpixel_normal_stepping(vec2 current_uniform_subpixel_position) {\n    current_uniform_subpixel_position.x         = current_uniform_subpixel_position.x + UNIFORM_RESONATE_STEP;\n    if (current_uniform_subpixel_position.x >= 1.0) {\n        current_uniform_subpixel_position.x     = current_uniform_subpixel_position.x - 1.0;\n        current_uniform_subpixel_position.y     = current_uniform_subpixel_position.y + UNIFORM_RESONATE_STEP;\n        if (current_uniform_subpixel_position.y >= 1.0) {\n            current_uniform_subpixel_position.y = current_uniform_subpixel_position.y - 1.0;\n        }\n    }\n    return current_uniform_subpixel_position;\n}\n\nvec2 position_jitter_subpixel(vec2 current_jitter_subpixel_position) {\n    vec2 next_jitter_subpixel_position          = current_jitter_subpixel_position + JITTERED_SUPERSAMPLE_RESONATE_STEP_VECTOR;\n    vec2 next_jitter_subpixel_position_fraction = fract(next_jitter_subpixel_position);\n    vec2 centered_next_jitter_subpixel_position = next_jitter_subpixel_position_fraction - NORMAL_CENTER_OFFSET;\n    return centered_next_jitter_subpixel_position;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tftGz7",
    "date": "1746928400",
    "viewed": 20,
    "name": "debug drekker minimal",
    "description": "I am going to take a break from this, and start looking at tiles shaders to get more exposure to the maths",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "test"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdXGzn",
       "filepath": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define TEXTURE_LOD_BASE_LEVEL 0.0\n\n\n//TODO: this scalar is suppose to shift the cells but it has a phase/period where it just loops in on itself\n// Im am not sure the bounds to make it fully reprpoduce a purely unique shift cycle\n//#define LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR    0.125\n#define LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR    0.0125\n\n#define HYPERBOLIC_AMPLITUDE 0.008\nfloat hyper(float column_index){\n    float hyper = HYPERBOLIC_AMPLITUDE;\n    return hyper;\n}\n\n#define CUBIC_SQUISH_SCALAR  0.0\n#define NORMAL_OFFSET_MAIN   0.5\n\n#define DEBUG\n#define DEBUG_LINE_THICKNESS_INNER 30.0\n#define DEBUG_LINE_THICKNESS_OUTER 10.0\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define CLEAR vec4(0.0, 0.0, 0.0, 0.0)\n#define GREENISH vec4(0.5, 1.0, 0.5, 1.0)\n#define VIOLET vec4(1.0, 0.0, 0.5, 1.0)\n\n\nfloat compute_horizontal_hyperbolic_curvature(float hyperbolic_amplitude, float cell_progress_x) {\n    float left_curve_downwards    = hyperbolic_amplitude * ((1.0 / cell_progress_x) - 1.0);\n    float right_curve_upwards     = hyperbolic_amplitude * ((1.0 / (1.0 - cell_progress_x)) - 1.0);\n    float curvature               = left_curve_downwards - right_curve_upwards;\n    return curvature;\n}\n\n\nfloat compute_vertical_cubic_color_squish(float local_cell_progress_y) {\n    return local_cell_progress_y * local_cell_progress_y * local_cell_progress_y;\n}\n\nvec4 debug_cell_border(float local_cell_progress_x, float local_cell_progress_y){\n    float bw = DEBUG_LINE_THICKNESS_OUTER / iResolution.y; \n    bool nearLeft   = local_cell_progress_x < bw;\n    bool nearRight  = local_cell_progress_x > 1.0 - bw;\n    bool nearBottom = local_cell_progress_y < bw;\n    bool nearTop    = local_cell_progress_y > 1.0 - bw;\n\n    if (nearLeft || nearRight || nearBottom || nearTop) {\n        return WHITE;\n    }\n    return CLEAR;\n}\n\nvec4 debug_hyper_plot(float column_index, float local_x, float local_y) {\n    float curv  = compute_horizontal_hyperbolic_curvature(hyper(column_index), local_x);\n    float normC = clamp((curv / HYPERBOLIC_AMPLITUDE + 1.0) * 0.5, 0.0, 1.0);\n\n    float inner = DEBUG_LINE_THICKNESS_INNER / iResolution.y;  \n    float outer = DEBUG_LINE_THICKNESS_OUTER / iResolution.y;   \n    float d     = abs(local_y - normC);\n\n    float dashCount = 50.0;\n    bool dash      = mod(floor(local_x * dashCount), 2.0) < 1.0;\n\n    if (!dash) {\n        if (d < inner) {\n            return GREENISH;   \n        } else if (d < outer) {\n            return CLEAR; \n        }\n    }\n    return CLEAR;\n}\n\nvec4 debug_cubic_plot(float local_x, float local_y) {\n    float phaseY = local_y - NORMAL_OFFSET_MAIN;\n    float squish  = compute_vertical_cubic_color_squish(phaseY);\n    float normT  = clamp(squish, 0.0, 1.0);\n\n    float inner = DEBUG_LINE_THICKNESS_INNER / iResolution.y;\n    float outer = DEBUG_LINE_THICKNESS_OUTER / iResolution.y;\n    float d     = abs(local_y - normT);\n    bool dash = mod(floor(local_x * 50.0), 2.0) < 1.0;\n\n    if (d < inner && dash) {\n        return VIOLET;\n    } else if (d < outer) {\n        return CLEAR;\n    }\n    return CLEAR;\n}\n\n\nfloat hypercell_x(out float column_index, out float local_cell_progress_x, float uv_x, float grid_dimensions_x) {\n    column_index          = compute_discrete_column_index(uv_x, grid_dimensions_x);\n    local_cell_progress_x = compute_local_cell_progress_x(uv_x, grid_dimensions_x);\n    float hyper_x         = compute_horizontal_hyperbolic_curvature(hyper(column_index), local_cell_progress_x);\n    //float hyper_x = 0.0;\n    return hyper_x;\n}\n\n\nfloat cubic_cell_squish(float local_cell_progress_y) {\n    float cubic_color_squish_cell_space = compute_vertical_cubic_color_squish(local_cell_progress_y);\n    //float cubic_color_squish = 0.0;\n    float cubic_color_squish_normal     = cubic_color_squish_cell_space / iResolution.y;\n    float cubic_color_squish_scaled     = CUBIC_SQUISH_SCALAR * cubic_color_squish_normal;\n    return cubic_color_squish_scaled;\n}\n\nfloat cubic_hypercell_y(out float row_index, out float local_cell_progress_y, float column_index, float uv_y, float grid_dimensions_y, float horizontal_hyperbolic_curvature) {\n    row_index               = compute_discrete_row_index(uv_y, grid_dimensions_y, horizontal_hyperbolic_curvature);\n    local_cell_progress_y   = compute_local_cell_progress_y(uv_y, grid_dimensions_y, horizontal_hyperbolic_curvature);\n    float cubic_cell_squish = cubic_cell_squish(local_cell_progress_y);\n    return cubic_cell_squish;\n}\n\nvec4 sample_uv_in_grid_space(vec2 uv, vec2 grid_dimensions) {\n    float column_index;\n    float local_cell_progress_x;\n    float hyper_curve = hypercell_x(column_index, local_cell_progress_x, uv.x, grid_dimensions.x);\n    float row_index;\n    float local_cell_progress_y;\n    float cubic_cell_squish = cubic_hypercell_y(row_index, local_cell_progress_y, column_index, uv.y, grid_dimensions.y, hyper_curve);\n    \n    float column_normal = column_index / grid_dimensions.x;\n    float row_normal    = row_index    / grid_dimensions.y;\n    float u = column_normal;\n    float vertical_color_offset       = LOCAL_CELL_SPACE_VERTICAL_SHIFT_SCALAR * column_index;\n    float v = row_normal + cubic_cell_squish - vertical_color_offset;\n    \n    vec4 texture_color = textureLod(iChannel0, vec2(u,v), TEXTURE_LOD_BASE_LEVEL);\n    \n    ALPHA_CLEAR_TEXELS_OUTSIDE_CELL_BOUNDARIES(texture_color, local_cell_progress_x, local_cell_progress_y);\n    \n    vec4 src_color = texture_color;\n    \n    #ifdef DEBUG\n        vec4 border_debug = debug_cell_border(local_cell_progress_x, local_cell_progress_y);\n        vec4 hyperplot_debug  = debug_hyper_plot(column_index, local_cell_progress_x, local_cell_progress_y);\n        vec4 cubicplot_debug  = debug_cubic_plot(local_cell_progress_x, local_cell_progress_y);\n        src_color.rgb = mix(src_color.rgb, border_debug.rgb, border_debug.a);\n        src_color.rgb = mix(src_color.rgb, hyperplot_debug.rgb,  hyperplot_debug.a);\n        src_color.rgb = mix(src_color.rgb, cubicplot_debug.rgb,  cubicplot_debug.a);\n        //NOTE on mix again..\n        /*\n        src_color.rgb = mix(src_color.rgb, hyperplot_debug.rgb,  hyperplot_debug.a);\n\n        ^this is the same as the following:\n\n        float a = hyperplot_debug.a;\n        src_color.r = src_color.r * (1.0 - a) + hyperplot_debug.r * a;\n        src_color.g = src_color.g * (1.0 - a) + hyperplot_debug.g * a;\n        src_color.b = src_color.b * (1.0 - a) + hyperplot_debug.b * a;\n        */\n    #endif\n    return src_color;\n}\n\n\nvec4 uniform_supersample(vec2 frag_coord, vec2 grid_dimensions) {\n    vec4 uniform_distribution = vec4(0.0);\n    int  remaining_subpixels_in_supersample = UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL;\n    vec2  current_uniform_subpixel_position = INITIAL_UNIFORM_STEP;\n    while (remaining_subpixels_in_supersample > 0) {\n        current_uniform_subpixel_position = position_uniform_subpixel_normal_stepping(current_uniform_subpixel_position);\n        vec2 sample_coord                  = frag_coord + current_uniform_subpixel_position;\n        vec2 uv                            = sample_coord / iResolution.y;\n        uniform_distribution               = uniform_distribution + sample_uv_in_grid_space(uv, grid_dimensions);\n        remaining_subpixels_in_supersample = remaining_subpixels_in_supersample - 1;\n    }\n    return uniform_distribution / UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv           = frag_coord / iResolution.y;\n    vec2 grid_dimensions = compute_grid_dimensions();\n    vec4 src_color = sample_uv_in_grid_space(uv, grid_dimensions);\n    if (src_color.a > 0.0) {\n        frag_color = src_color;\n    } else {\n        src_color = uniform_supersample(frag_coord, grid_dimensions);\n        frag_color = src_color;\n    }\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define GRID_COLUMNS           1.125\n#define GRID_ROWS              2.74\n//#define GRID_COLUMNS             9.125 / 2.33\n//#define GRID_ROWS                7.0 / 3.0\n\n#define NORMAL_CENTER_OFFSET   0.5\n#define UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL   64\n#define UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F float(UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL)\n\n#define UNIFORM_RESONATE_STEP                                     1.0 / sqrt(UNIFORM_SUPERSAMPLE_RESOLUTION_SUBPIXEL_SAMPLES_PER_PIXEL_F)\n#define INITIAL_UNIFORM_STEP                                      vec2(NORMAL_CENTER_OFFSET)\n\nvec2 position_uniform_subpixel_normal_stepping(vec2 current_uniform_subpixel_position) {\n    current_uniform_subpixel_position.x         = current_uniform_subpixel_position.x + UNIFORM_RESONATE_STEP;\n    if (current_uniform_subpixel_position.x >= 1.0) {\n        current_uniform_subpixel_position.x     = current_uniform_subpixel_position.x - 1.0;\n        current_uniform_subpixel_position.y     = current_uniform_subpixel_position.y + UNIFORM_RESONATE_STEP;\n        if (current_uniform_subpixel_position.y >= 1.0) {\n            current_uniform_subpixel_position.y = current_uniform_subpixel_position.y - 1.0;\n        }\n    }\n    return current_uniform_subpixel_position;\n}\n\n#define MARGIN 0.0 //TODO: this doesnt have enough effect for me to understand, i think its aa...\n#define LOCAL_CELL_SPACE_UPPER_AND_LOWER_BOUNDARY MARGIN\n#define LOCAL_CELL_SPACE_BOUNDARY_LEFT            MARGIN\n#define LOCAL_CELL_SPACE_BOUNDARY_RIGHT           1.0 - MARGIN\n\n\n#define ALPHA_CLEAR_TEXELS_OUTSIDE_CELL_BOUNDARIES(color, x, y) {  \\\n            if ( abs(y) > LOCAL_CELL_SPACE_UPPER_AND_LOWER_BOUNDARY \\\n               || (x)   < LOCAL_CELL_SPACE_BOUNDARY_LEFT            \\\n               || (x)   > LOCAL_CELL_SPACE_BOUNDARY_RIGHT) {       \\\n                (color).a = 0.0;                               \\\n            }                                                \\\n        }\n\n\n///MISC AUX:\nvec2 compute_grid_dimensions() {\n    return vec2(GRID_COLUMNS, GRID_ROWS);\n}\n\nfloat compute_discrete_column_index(float uv_x, float grid_width_in_columns) {\n    float column_units_x = uv_x * grid_width_in_columns;\n    float discrete_column_index = floor(column_units_x);\n    return discrete_column_index;\n}\n\nfloat compute_local_cell_progress_x(float uv_x, float grid_width_in_columns) {\n    float column_units_x    = uv_x * grid_width_in_columns;\n    float local_cell_progress_x = fract(column_units_x);\n    return local_cell_progress_x;\n}\n\n\nfloat compute_discrete_row_index(float uv_y, float grid_height_in_rows, float horizontal_hyperbolic_curvature) {\n    float row_y        = uv_y * grid_height_in_rows;\n    float curved_row_y = row_y + horizontal_hyperbolic_curvature;\n    float discrete_row_index_after_curve = floor(curved_row_y);\n    return discrete_row_index_after_curve;\n}\n\nfloat compute_local_cell_progress_y(float uv_y, float grid_height_in_rows, float horizontal_hyperbolic_curvature) {\n    float row_y        = uv_y * grid_height_in_rows;\n    float curved_row_y = row_y + horizontal_hyperbolic_curvature;\n    float local_cell_progress_y_after_curve = fract(curved_row_y);\n    return local_cell_progress_y_after_curve;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3c3GW8",
    "date": "1747012578",
    "viewed": 36,
    "name": "Fork These wave meisei4 435",
    "description": "sine uv's basic practice thing fork",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "waves",
     "tiles"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xdf3zn",
       "filepath": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float scale = 2.0;  \nconst vec2 tileSize = vec2(1.0) / scale;\n\nconst vec2 targetTile = vec2(0.0, 0.0);\nconst vec2 moveTile = vec2(1.33, 0.5); \n\nconst vec2 origin = (targetTile + moveTile) * tileSize;\n\nfloat BAYER_DIVISION_SCALAR = 8.0;\nfloat dither_interpolation_weight = 0.5;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.yy;\n    vec2 local = (uv - origin) * scale;\n    if (local.x < 0.0 || local.x > 1.0 || local.y < 0.0 || local.y > 1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    local.x += 0.16 * sin(local.y * 6.0 + uv.y + iTime * 4.0);\n    local.y += 0.10 * cos(local.x * 8.0 + iTime * 2.3);\n\n    float radius = 0.35;\n    float d = length(local - vec2(0.5));\n    float c = smoothstep(radius, radius - 0.01, d);\n    d *= local.x;\n    d -= floor(local.y / 30.0);\n    float shade = mix(0.0, 1.0, d * 8.0);\n   \n    vec4 color = vec4(c * shade);\n\n    float bayer_threshold = texture(iChannel0, fragCoord / BAYER_DIVISION_SCALAR).r;\n    vec4 dithered = step(bayer_threshold, color);\n    color = mix(color, dithered, dither_interpolation_weight);\n    color.a = 1.0;\n    fragColor = color;\n}\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wf3GW8",
    "date": "1747014609",
    "viewed": 46,
    "name": "ghost thing",
    "description": "attempting som animation thing for ghost enityt",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "dither",
     "ghost"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xdf3zn",
       "filepath": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//inspired by and forked from https://www.shadertoy.com/view/wstBD4\n\nconst float scale = 2.0;  \nconst vec2 tileSize = vec2(1.0) / scale;\n\nconst vec2 targetTile = vec2(0.0, 0.0);\nconst vec2 moveTile = vec2(1.33, 0.5); \n\nconst vec2 origin = (targetTile + moveTile) * tileSize;\n\nfloat BAYER_DIVISION_SCALAR = 8.0;\nfloat dither_interpolation_weight = 0.75;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime;\n    vec2 uv    = fragCoord / iResolution.yy;\n    vec2 local = (uv - origin) * scale;\n    float dx = 0.02 * cos(local.y * 6.0 + uv.y + t * 100.0);\n    float dy = 0.10 * sin(local.x * 8.0 + t * 2.3);\n    local.x += dx;\n    local.y += dy;\n    \n    local.xy += sin(iTime + local.yx)*.3;\n    \n    float radius = 0.35;\n    float dShape = length(local - vec2(0.5));\n    float mask   = smoothstep(radius, radius - 0.01, dShape);\n\n    vec2 distortAtCenter = vec2(\n        0.06 * cos(0.9 * 6.0 + uv.y + t * 100.0),\n        0.14 * cos(0.2 * 8.0 + t * 2.3)\n    );\n    vec2 shapeCenter = vec2(0.5) + distortAtCenter;\n\n    vec2 lightPos = shapeCenter + vec2(-radius / 2.5, -radius / 1.0);\n    float lo = length(local - lightPos);\n    float shade = smoothstep(0.1, radius *1.0, lo / 2.0);\n    float bayer_threshold = texture(iChannel0, fragCoord / BAYER_DIVISION_SCALAR).r;\n    vec4 color  = vec4(mask * shade);\n    vec4 dither = step(bayer_threshold, color);\n    color = mix(color, dither, dither_interpolation_weight);\n    color.a = 1.0;\n\n    fragColor = color;\n}\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3c3GWH",
    "date": "0",
    "viewed": 0,
    "name": "ghost dither",
    "description": "ghost",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "dither",
     "ghost"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xdf3zn",
       "filepath": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// this is a verbose, constant-driven rewrite with “smooth” ASCII diagrams and detailed explanations\n//shader_type canvas_item;\n//render_mode blend_disabled; \n\n//uniform vec2   iResolution;                  \n//uniform float  iTime;              \n//uniform sampler2D iChannel0 : filter_nearest_mipmap, repeat_enable; \n\nconst float SCALE             = 2.0;                     // zoom factor for tile grid\nconst vec2  TILE_SIZE         = vec2(1.0) / SCALE;       // size of one tile in UV space\nconst vec2  TARGET_TILE       = vec2(0.0, 0.0);           // base tile index\nconst vec2  MOVE_TILE         = vec2(1.33, 0.5);          // offset tile index\nconst vec2  ORIGIN            = (TARGET_TILE + MOVE_TILE) * TILE_SIZE; \n\n\nconst float DX_AMP            = 0.02;    // horizontal wave amplitude\nconst float DX_FREQ           = 6.0;     // horizontal wave spatial frequency\nconst float DX_SPEED          = 100.0;   // horizontal wave temporal frequency\n\nconst float DY_AMP            = 0.10;    // vertical wave amplitude\nconst float DY_FREQ           = 8.0;     // vertical wave spatial frequency\nconst float DY_SPEED          = 2.3;     // vertical wave temporal frequency\n\n\n\n\nconst float CIRCLE_RADIUS     = 0.35;    // radius of circular mask\nconst float EDGE_SOFT         = 0.01;    // softness width for smooth edge\n\n\n\nconst float BAYER_SCALE       = 8.0;  \nconst float DITHER_WEIGHT     = 0.75; \n\n/*\n   Smooth ASCII: cosine distortion over uv.y + time\n\n       offset\n      0.02 ─  ~~~\\     /~~~~\\    ~~~\n            /     \\   /      \\\n    −0.02 ─        \\_/        \\__\n             uv.y + t → increases\n*/\n\n//and sine::\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n//void fragment() {\n    //vec2 frag_coord = UV * iResolution;\n    vec2 uv        = frag_coord / iResolution.yy;\n\n    vec2 local = (uv - ORIGIN) * SCALE;\n    float t = iTime;\n    float x_jittered_time = t * DX_SPEED;\n    float y_jittered_time = t * DY_SPEED;\n\n    float dx = DX_AMP * cos(local.y * DX_FREQ + uv.y + iTime * DX_SPEED);\n    float dy = DY_AMP * sin(local.x * DY_FREQ + iTime * DY_SPEED);\n    local.x += dx;\n    local.y += dy;\n\n    float distance_to_local = length(local - vec2(0.5));\n    float mask  = smoothstep(CIRCLE_RADIUS, CIRCLE_RADIUS - EDGE_SOFT, distance_to_local);\n\n    vec2 centerOffset = vec2(\n        DX_AMP * cos(0.9 * DX_FREQ + uv.y + iTime * DX_SPEED),\n        DY_AMP * cos(0.2 * DY_FREQ + iTime * DY_SPEED)\n    );\n    vec2 shapeCenter = vec2(0.5) + centerOffset;\n    vec2 lightPos    = shapeCenter + vec2(-CIRCLE_RADIUS/2.5, -CIRCLE_RADIUS);\n    float lightD     = length(local - lightPos);\n    float shade      = smoothstep(0.1, CIRCLE_RADIUS, lightD * 0.5);\n\n    float bayer_threshold = texture(iChannel0, frag_coord / BAYER_SCALE).r;\n\n    vec4 masked_color = vec4(mask * shade);\n\n    vec4 dithered_color = step(bayer_threshold, masked_color);\n    vec4 src_color = mix(masked_color, dithered_color, DITHER_WEIGHT);\n\n    src_color.a = 1.0;\n    frag_color = src_color;\n    //COLOR = frag_color;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wccGW8",
    "date": "0",
    "viewed": 0,
    "name": "Fork reality wa meisei4 458",
    "description": "warped and shaded bathroom tiles.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "grid",
     "wireframe",
     "monochrome",
     "lights",
     "neon"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImagea( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    \n    float t = (iTime+1.3)*2.;\n    float c = .0, d = .0, s = .0;\n    \n    for(float f = -5.; f < 1.; f += .6)\n    {\n        s = 20.;\n        \n        if (p.x > .0)\n        \ts = 20. + sin(  tan( (p.x+p.y)/(p.x/p.y))*10.  )*2.;\n        \t//s = 20. + sin(f+ sin(p.x/p.y)*5. )*10.;\n        \n        d = distance(\n              vec3( tan(p.x*s+t), tan(p.y*s+t), f ),\n              vec3( p.x*20., .0, -5. )\n            );\n        \n    \tc += d * sin(t + .5/p.x + cos(p.y)*5. ) * .01;\n    }\n    \n\tfragColor = vec4(.5-c, .6-c*.25,1.-c*.5, 1.);\n    //fragColor = vec4(1.-c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    float t = (iTime + 1.3) * 2.0;\n    float c = 0.0;\n    float d = 0.0;\n    float s = 0.0;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    bool right = (uv.x > 0.5);\n\n    vec2 gridUV = vec2(\n        right ? (uv.x - 0.5) * 2.0 : uv.x * 2.0,\n        uv.y\n    );\n\n    const float SPACING = 10.00;\n    const float LINE_W  = 0.02;\n\n    vec2 scaled = vec2(\n        gridUV.x * SPACING * 0.50,\n        gridUV.y * SPACING * (iResolution.y / iResolution.x)\n    );\n\n    if (!right)\n    {\n        float gx = abs(fract(scaled.x) - 0.5);\n        float gy = abs(fract(scaled.y) - 0.5);\n        float line = step(gx, LINE_W) + step(gy, LINE_W);\n        line = clamp(line, 0.0, 1.0);\n        fragColor = vec4(1.-line);\n        return;\n    }\n\n    for (float f = -5.0; f < 1.0; f += 0.6)\n    {\n        s = 20.0;\n        if (p.x > 0.0) {\n            s += sin(tan((p.x + p.y) / (p.x / p.y)) * 10.0) * 2.0;\n        }\n        \n        d = distance(\n            vec3(tan(p.x * s + t), tan(p.y * s + t), f),\n            vec3(p.x * 20.0, 0.0, -5.0)\n        );\n        c = d * sin(t + 0.5 / p.x + cos(p.y) * 5.0) * 0.01;\n    }\n\n    vec2 offset = clamp(vec2(c,c), -0.5, 0.5);\n\n    gridUV += offset;\n    scaled = vec2(\n        gridUV.x * SPACING * 1.5,\n        gridUV.y * SPACING * (iResolution.y / iResolution.x)\n    );\n\n    float gx = abs(fract(scaled.x) - 0.5);\n    float gy = abs(fract(scaled.y) - 0.5);\n    float line = step(gx, LINE_W) + step(gy, LINE_W);\n    line = clamp(line, 0.0, 1.0);\n    fragColor = vec4(1.-c);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wct3W4",
    "date": "1747119384",
    "viewed": 49,
    "name": "gohst verbohst",
    "description": "aftgshdjkflgi",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "dither",
     "study",
     "ghost",
     "spooky",
     "jitter"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xdf3zn",
       "filepath": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Still not really that good of naming of variables, i fell into the function decomposition trap again....\n\n#define HALF 0.5  \n#define GRID_SCALE               2.0                  \n#define GRID_CELL_SIZE           (vec2(1.0) / GRID_SCALE)  \n#define GRID_ORIGIN_INDEX        vec2(0.0)             \n#define GRID_ORIGIN_OFFSET_CELLS vec2(1.33, 0.5)    \n#define GRID_ORIGIN_UV_OFFSET    ((GRID_ORIGIN_INDEX + GRID_ORIGIN_OFFSET_CELLS) * GRID_CELL_SIZE)  \n#define CELL_DRIFT_AMPLITUDE    0.2 \n//   • Units: grid‐space UV units\n//   • Domain ~[0.0–1.0] (0 = no drift, 1 = very strong drift)\n//   • Controls how far each cell “wobbles” over time\n#define LIGHT_WAVE_SPATIAL_FREQ_X     8.0                     \n#define LIGHT_WAVE_SPATIAL_FREQ_Y     8.0  \n//   • Units: radians per cell\n//   • Domain >0 (higher = more crests per cell)\n#define LIGHT_WAVE_TEMPORAL_FREQ_X    80.0                    \n#define LIGHT_WAVE_TEMPORAL_FREQ_Y    2.3                    \n//   • Units: radians per second\n//   • Domain >0 (higher = faster animation)\n#define LIGHT_WAVE_AMPLITUDE_X        0.03                   \n#define LIGHT_WAVE_AMPLITUDE_Y        0.1    \n//   • Units: grid‐space UV offset\n//   • Domain ~[0.0–0.5] (small to subtle; >0.2 very wavy)\n//   • Max horizontal or vertical displacement per wave\n#define UMBRAL_MASK_OUTER_RADIUS     0.40  // bad name this is not for the umbral mask but rather the whole grid!\n#define UMBRAL_MASK_INNER_RADIUS     0.08             \n//   • Region inside which mask is solid (no fade)\n#define UMBRAL_MASK_FADE_BAND         0.025  \n//   • Width of the fade band between inner & outer radius\n#define UMBRAL_MASK_CENTER           vec2(HALF, HALF)    \n#define UMBRAL_MASK_OFFSET_X         (-UMBRAL_MASK_OUTER_RADIUS /1.0)     \n#define UMBRAL_MASK_OFFSET_Y         (-UMBRAL_MASK_OUTER_RADIUS)  \n#define UMBRAL_MASK_PHASE_COEFFICIENT_X  0.6\n#define UMBRAL_MASK_PHASE_COEFFICIENT_Y  0.2  \n#define UMBRAL_MASK_WAVE_AMPLITUDE_X     0.1                       \n#define UMBRAL_MASK_WAVE_AMPLITUDE_Y     0.1                      \n\n#define DITHER_TEXTURE_SCALE    8.0                     \n#define DITHER_BLEND_FACTOR     0.75                     \n\nvec2 uv_to_grid_space(vec2 uv, float time) {\n    uv = uv - GRID_ORIGIN_UV_OFFSET;\n    vec2 grid_coords = uv * GRID_SCALE;\n    return grid_coords;\n}\n\nvec2 warp_and_drift_cell(vec2 grid_coords, float time) {\n    return CELL_DRIFT_AMPLITUDE * sin(time + grid_coords.yx);\n}\n\nvec2 spatial_phase(vec2 grid_coords) {\n    return vec2(\n        grid_coords.y * LIGHT_WAVE_SPATIAL_FREQ_X,\n        grid_coords.x * LIGHT_WAVE_SPATIAL_FREQ_Y\n    );\n}\n\nvec2 temporal_phase(float time) {\n    return vec2(\n        time * LIGHT_WAVE_TEMPORAL_FREQ_X,\n        time * LIGHT_WAVE_TEMPORAL_FREQ_Y\n    );\n}\n\nvec2 add_phase(vec2 phase) {\n    float offset_x = LIGHT_WAVE_AMPLITUDE_X * cos(phase.x);\n    float offset_y = LIGHT_WAVE_AMPLITUDE_Y * sin(phase.y);\n    return vec2(offset_x, offset_y);\n}\n\nvec4 light_radial_fade(vec2 grid_coords, vec2 center, float radius, float feather) {\n    float distance_from_center = length(grid_coords - center);\n    float fade_start = radius - feather;\n    float alpha = 1.0 - smoothstep(fade_start, radius, distance_from_center);\n    vec4 lightball = vec4(clamp(alpha, 0.0, 1.0));\n    return lightball;\n}\n       \nvec2 add_umbral_mask_phase(float time){\n    vec2 phase = vec2(0.0);\n    phase.x = UMBRAL_MASK_WAVE_AMPLITUDE_X * LIGHT_WAVE_SPATIAL_FREQ_X;\n    phase.y = UMBRAL_MASK_WAVE_AMPLITUDE_Y * LIGHT_WAVE_SPATIAL_FREQ_Y + time * LIGHT_WAVE_TEMPORAL_FREQ_Y;\n    return phase;\n}\n\nvec2 umbral_mask_position(float x_phase_coefficient, float y_phase_coefficient, vec2 mask_phase) {\n    float mask_pos_x = x_phase_coefficient * cos(mask_phase.x);\n    float mask_pos_y = y_phase_coefficient * sin(mask_phase.y);\n    vec2 offset_mask = vec2(mask_pos_x, mask_pos_y) + UMBRAL_MASK_CENTER;\n    return offset_mask;\n}\n\nvec4 add_umbral_mask(vec4 src_color, vec2 grid_coords, vec2 mask_center) {\n    vec2  mask_pos  = mask_center + vec2(UMBRAL_MASK_OFFSET_X, UMBRAL_MASK_OFFSET_Y);\n    float dist        = length(grid_coords - mask_pos);\n    float half_dist   = dist * HALF;\n    float mask        = smoothstep(UMBRAL_MASK_INNER_RADIUS, UMBRAL_MASK_OUTER_RADIUS, half_dist);\n    vec4  applied_mask = src_color * mask;\n    return applied_mask;\n}\n\nvec4 add_dither(vec4 src_color, vec2 frag_coord) {\n    vec2 dither_uv = frag_coord / DITHER_TEXTURE_SCALE;\n    float dither_sample = texture(iChannel0, dither_uv).r;\n    vec4 dither_mask = vec4(dither_sample);\n    vec4 binary = step(dither_mask, src_color);\n    vec4 applied_dither = mix(src_color, binary, DITHER_BLEND_FACTOR);\n    return applied_dither;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    float time        = iTime;\n    vec2 uv           = frag_coord / vec2(iResolution.y);\n    \n    //prepare base grid cell warping and drifting\n    vec2 grid_coords  = uv_to_grid_space(uv, time);\n    vec2 grid_phase   = vec2(0.0);\n    grid_phase       += spatial_phase(grid_coords);\n    grid_phase       += temporal_phase(time);\n    grid_coords      += add_phase(grid_phase);\n    grid_coords      += warp_and_drift_cell(grid_coords, time);\n    \n    //set up light ball inside target grid cell\n    vec4 lightball    = light_radial_fade(grid_coords, UMBRAL_MASK_CENTER, UMBRAL_MASK_OUTER_RADIUS, UMBRAL_MASK_FADE_BAND);\n    vec4 src_color    = lightball;\n    \n    //set up umbral mask to be drawn on top of transformed light ball\n    vec2 umbral_mask_phase = vec2(0.0);\n    umbral_mask_phase     += add_umbral_mask_phase(time);\n    vec2 umbral_mask_pos   = umbral_mask_position(UMBRAL_MASK_PHASE_COEFFICIENT_X, UMBRAL_MASK_PHASE_COEFFICIENT_Y, umbral_mask_phase);\n    \n    //add the umbral mask to the light ball\n    src_color         = add_umbral_mask(src_color, grid_coords, umbral_mask_pos);\n    src_color         = add_dither(src_color, frag_coord);\n    frag_color.a      = 1.0;\n    frag_color        = src_color;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfc3zB",
    "date": "1747211422",
    "viewed": 29,
    "name": "lightbal rhtyhm thing",
    "description": "this is starting to debug godot'S rhythm analyser code (im going to puslate the ball in the top right, and visually debug with the FFT texture vs just godot audio effect rhythm derivations",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fft",
     "audio",
     "dither"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xdf3zn",
       "filepath": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define HALF                        0.5  \n#define GRID_SCALE                  4.0                  \n#define GRID_CELL_SIZE              (vec2(1.0) / GRID_SCALE)  \n#define GRID_ORIGIN_INDEX           vec2(0.0)             \n#define GRID_ORIGIN_OFFSET_CELLS    vec2(5.66, 2.66)    \n#define GRID_ORIGIN_UV_OFFSET       ((GRID_ORIGIN_INDEX + GRID_ORIGIN_OFFSET_CELLS) * GRID_CELL_SIZE)  \n#define CELL_DRIFT_AMPLITUDE        0.2 \n#define LIGHT_WAVE_SPATIAL_FREQ_X   8.0                     \n#define LIGHT_WAVE_SPATIAL_FREQ_Y   8.0  \n#define LIGHT_WAVE_AMPLITUDE_X      0.03                   \n#define LIGHT_WAVE_AMPLITUDE_Y      0.1    \n#define LIGHTBALL_OUTER_RADIUS      0.40  \n#define LIGHTBALL_FADE_BAND         0.025  \n#define LIGHTBALL_CENTER            vec2(HALF, HALF)    \n#define DITHER_TEXTURE_SCALE        8.0                     \n#define DITHER_BLEND_FACTOR         0.75                     \n\n#define total_fft_buffer_size_in_bins 512.0\n#define WHITE                         vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK                         vec4(0.0, 0.0, 0.0, 1.0)\n#define FFT_ROW                       0.0\n\n// ——— Lightball/Grid Functions ———\nvec2 uv_to_grid_space(vec2 uv, float time) {\n    uv = uv - GRID_ORIGIN_UV_OFFSET;\n    vec2 grid_coords = uv * GRID_SCALE;\n    return grid_coords;\n}\n\nvec2 warp_and_drift_cell(vec2 grid_coords, float time) {\n    return CELL_DRIFT_AMPLITUDE * sin(time + grid_coords.yx);\n}\n\nvec2 spatial_phase(vec2 grid_coords) {\n    return vec2(\n        grid_coords.y * LIGHT_WAVE_SPATIAL_FREQ_X,\n        grid_coords.x * LIGHT_WAVE_SPATIAL_FREQ_Y\n    );\n}\n\nvec2 add_phase(vec2 phase) {\n    float offset_x = LIGHT_WAVE_AMPLITUDE_X * cos(phase.x);\n    float offset_y = LIGHT_WAVE_AMPLITUDE_Y * sin(phase.y);\n    return vec2(offset_x, offset_y);\n}\n\nvec4 light_radial_fade(vec2 grid_coords, vec2 center, float radius, float feather) {\n    float distance_from_center = length(grid_coords - center);\n    float fade_start = radius - feather;\n    float alpha = 1.0 - smoothstep(fade_start, radius, distance_from_center);\n    vec4 lightball = vec4(clamp(alpha, 0.0, 1.0));\n    return lightball;\n}\n\nvec4 add_dither(vec4 src_color, vec2 frag_coord) {\n    vec2 dither_uv = frag_coord / DITHER_TEXTURE_SCALE;\n    float dither_sample = texture(iChannel0, dither_uv).r;\n    vec4 dither_mask = vec4(dither_sample);\n    vec4 binary = step(dither_mask, src_color);\n    vec4 applied_dither = mix(src_color, binary, DITHER_BLEND_FACTOR);\n    return applied_dither;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    // 1) FFT histogram across the full screen\n    vec2 uv_full = frag_coord.xy / iResolution.xy;\n    float cell_width = iResolution.x / total_fft_buffer_size_in_bins;\n    float bin_index  = floor(frag_coord.x / cell_width);\n    float local_x    = mod(frag_coord.x, cell_width);\n    float bar_width  = cell_width - 1.0;\n    vec4 fft_color = BLACK;\n    if (local_x <= bar_width) {\n        float sample_x = (bin_index + 0.5) / total_fft_buffer_size_in_bins;\n        float amplitude = texture(iChannel1, vec2(sample_x, FFT_ROW)).r;\n        if (uv_full.y < amplitude) {\n            fft_color = WHITE;\n        }\n    }\n    frag_color = fft_color;\n\n    // 2) Drifting lightball in the top-right grid cell\n    float time = iTime;\n    vec2 uv = frag_coord.xy / vec2(iResolution.y);\n    \n    vec2 grid_coords = uv_to_grid_space(uv, time);\n    vec2 grid_phase  = spatial_phase(grid_coords);\n    //grid_coords     += add_phase(grid_phase);\n    //grid_coords     += warp_and_drift_cell(grid_coords, time);\n    \n    vec4 lightball = light_radial_fade(\n        grid_coords, \n        LIGHTBALL_CENTER, \n        LIGHTBALL_OUTER_RADIUS, \n        LIGHTBALL_FADE_BAND\n    );\n    vec4 src_color = add_dither(lightball, frag_coord);\n\n    // overlay the lightball over the FFT histogram\n    frag_color = max(frag_color, src_color);\n    frag_color.a = 1.0;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wct3zj",
    "date": "1747265851",
    "viewed": 19,
    "name": "test show ",
    "description": "test",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "test"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xdf3zn",
       "filepath": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// trying to return to https://www.shadertoy.com/view/wstBD4\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.yy;\n    float t = iTime;   \n    vec4 cSum = vec4(0.0);\n    for(float x = -1.; x < 1.0001; x++) {\n        for(float y = -1.; y < 1.0001; y++) {\n            vec2 gv = fract(uv * 4.);\n            if(x != vec2(floor(uv * 4.)).x || y != vec2(floor(uv * 4.)).y) continue;\n            vec2 phase = vec2(gv.y * 8. + t * 80., gv.x * 8. + t * 2.);\n            gv += vec2(.03 * cos(phase.x), .1  * sin(phase.y));\n            gv += .2 * sin(t + gv.yx);\n            float d1  = length(gv - vec2(.5));\n            float lum = 1. - smoothstep(.375, .4, d1);\n            vec4 col = vec4(clamp(lum, 0., 1.));\n            vec2 mphase = vec2(.1 * 8., .1 * 8. + t * 2.);\n            vec2 mctr = vec2(.6 * cos(mphase.x),.2 * sin(mphase.y)) + vec2(.5);\n            vec2 mpos = mctr - vec2(.4);\n            float d2  = length(gv - mpos) * .5;\n            float msk = smoothstep(.08, .4, d2);\n            col *= msk;\n            vec2 dUV  = fragCoord / 8.;\n            float ds  = texture(iChannel0, dUV).r;\n            vec4 bin  = step(vec4(ds), col);\n            col       = mix(col, bin, .7);\n            cSum += col;\n        }\n    }\n    fragColor = cSum;\n}\n\n\n\n//full golf????\nvoid mainImage_golf(out vec4 o,in vec2 f){\n float t=iTime;\n vec2 uv=f/vec2(iResolution.y),p=(uv-vec2(.665,.25))*2.,ph=vec2(p.y*8.+t*80.,p.x*8.+t*2.3);\n p+=vec2(.03*cos(ph.x),.1*sin(ph.y));p+=.2*sin(t+p.yx);\n vec4 c=vec4(clamp(1.-smoothstep(.375,.4,length(p-vec2(.5))),0.,1.));\n vec2 m=vec2(.1+.6*cos(.8),.1+.2*sin(.8+2.3*t));\n c*=smoothstep(.08,.4,length(p-m)*.5);\n c=mix(c,step(vec4(texture(iChannel0,f/8.).r),c),.75);\n o=vec4(c.rgb,1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  }
 ]
}